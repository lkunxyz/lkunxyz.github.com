<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keen on Art of Tech]]></title>
  <link href="http://lkunxyz.github.com/atom.xml" rel="self"/>
  <link href="http://lkunxyz.github.com/"/>
  <updated>2013-01-01T20:55:27+08:00</updated>
  <id>http://lkunxyz.github.com/</id>
  <author>
    <name><![CDATA[Tiny]]></name>
    <email><![CDATA[admin@tinyxd.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[开始找工作了]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/09/10/job-hunting-2012/"/>
    <updated>2012-09-10T00:24:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/09/10/job-hunting-2012</id>
    <content type="html"><![CDATA[<p>今天，航天二院专场招聘，正式拉开了招聘的序幕。人好多！  <br/>
<img src="http://upload.tinyxd.me/2012/09/job.JPG"  alt="Job Hunting" width="970" height="660"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个人网站上安装SSL证书]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/09/02/nginx-ssl/"/>
    <updated>2012-09-02T22:45:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/09/02/nginx-ssl</id>
    <content type="html"><![CDATA[<p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。   <br/>
HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，HTTPS应用了Netscape的完全套接字层（SSL）作为HTTP应用层的子层。（HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）   <br/>
建个网站不容易，各种都要收费，那么有免费的当然就更好了！免费的SSL证书：<a href="https://www.startssl.com/">StartSSL</a>来了！ <br/>
1.进入StartSSL<a href="https://www.startssl.com/">官网</a>，点击左上角<code>Sign-up For Free</code>（这个很容易找，就不截图了<code>^_^</code>）。按要求填写注册信息，<code>First, Last Name</code>这一栏填写自己的中文名字的拼音，地址精确到房间号或者街道号（要不然客服发来邮件会索要地址的）。 <br/>
2.注册成功后，StartSSL会发送一个链接给你，还有验证码。因为StartSSL使用证书验证的，所以，要把验证证书好好保管好，丢了就没法登陆了。 <br/>
3.进入<code>Control Panel</code>之后，点击<code>Validations Wizard</code>，域名验证<code>Domain Name Validation</code>,填入你需要添加SSL的域名，还有你的个人邮箱（会给你发封邮件，里面有验证码，注意接收）。 <br/>
4.验证完域名后，点击<code>Certificates Wizard</code>&#8211;<code>Web Server SSL/TLS Certificate</code>。</p>

<!--more-->


<p><strong>生成私钥（Generate Private Key）</strong> <br/>
如果你已经在VPS上生成了私钥，这一步可以跳过，没有的话，可以在这里生成，填入私钥的密码，将文本框中的内容复制，保存为<code>ssl.key</code>。 <br/>
<strong>生成证书</strong>  <br/>
选择你需要绑定的二级域名，比如<code>www.tinyxd.me</code>,<code>Tool Box</code>&#8211;<code>Retrieve Certificate</code>,同样将文本框中的内容复制另存为<code>ssl.crt</code>。  <br/>
<strong>登录VPS，生成服务器密钥/证书</strong>  <br/>
生成<code>server.key</code></p>

<pre><code>openssl rsa -in ssl.key -out server.key
</code></pre>

<p>生成<code>server.crt</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cp ssl.crt server.crt
</span><span class='line'>wget http://cert.startssl.com/certs/ca.pem
</span><span class='line'>wget http://cert.startssl.com/certs/sub.class1.server.ca.pem
</span><span class='line'>cat ca.pem sub.class1.server.ca.pem &gt;&gt; ca-certs.crt
</span><span class='line'>cat ca-certs.crt &gt;&gt; server.crt
</span></code></pre></td></tr></table></div></figure>


<p><strong>修改nginx配置文件</strong>  <br/>
将<code>server.key</code>和<code>server.crt</code>放到<code>/usr/local/nginx/certs/</code>目录下，修改<code>/usr/local/nginx/conf/vhost/</code>对应域名虚拟机的配置文件，添加如下内容：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>server <span class="o">{</span>
</span><span class='line'>listen 80;
</span><span class='line'>server_name www.域名.com;
</span><span class='line'>rewrite ^<span class="o">(</span>.*<span class="o">)</span> https://<span class="nv">$server_name$1</span> permanent;
</span><span class='line'><span class="o">}</span>
</span><span class='line'>server <span class="o">{</span>
</span><span class='line'>listen 443;
</span><span class='line'>server_name www.域名.com;
</span><span class='line'>root /home/www;
</span><span class='line'>ssl on;
</span><span class='line'>ssl_certificate /usr/local/nginx/certs/server.crt;
</span><span class='line'>ssl_certificate_key /usr/local/nginx/certs/server.key;
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面脚本的<code>rewrite ^(.*) https://$server_name$1 permanent;</code>如果不填加的话，你的网站将可以进行http和https的两种访问。  <br/>
最后重启Nginx，<code>/usr/local/nginx restart</code> 。访问你的网站，看是不是支持https访问了！ <br/>
本文参考：<a href="http://ichon.me/2012/5/29/nginx-ssl.html">http://ichon.me/2012/5/29/nginx-ssl.html</a>和<a href="http://baike.baidu.com/view/16147.htm">http://baike.baidu.com/view/16147.htm</a></p>

<br />


<p>本文地址：<a href="http://tinyxd.me/blog/2012/09/02/nginx-ssl/">http://tinyxd.me/blog/2012/09/02/nginx-ssl/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VPS安装openVPN]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/30/debian-ubuntu-setup-openvpn/"/>
    <updated>2012-08-30T12:24:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/30/debian-ubuntu-setup-openvpn</id>
    <content type="html"><![CDATA[<p>首先，你得有VPS或者独立服务器。 <br/>
因为我的VPS是openVZ的，查资料发现新的openVZ的VPS是支持PPTP的。不过鉴于安全性的考虑我还是使用openVPN。 <br/>
本文后面会介绍在debian 6下面安装openvpn的一些注意事项以及在xp下面安装openVPN。</p>

<h2>使用一键安装包来安装openVPN   </h2>

<p>1.检查你的VPS是否支持Tun/Tap/nat/ppp，登录VPS检查</p>

<pre><code>cat /dev/net/tun
</code></pre>

<p>如果返回 <code>cat: /dev/net/tun: File descriptor in bad state</code> 说明tun是可用的。</p>

<pre><code>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o venet0 -j MASQUERADE
</code></pre>

<p>如果返回<code>iptables: No chain/target/match by that name</code>说明nat也是可以用的。</p>

<!--more-->


<p>如果返回结果不是以上描述的，那么说明你的VPS服务商默认没有开通。你可以发ticket要求VPS提供商提供这个，我的VPS就没有提供这个，就发了ticket，不过很快就解决了。 <br/>
2.检查服务器的DNS</p>

<pre><code>vi /etc/resolv.conf
</code></pre>

<p>可以使用  <br/>
OpenDNS提供的DNS服务器地址
　　208.67.222.222
　　208.67.220.220
Google提供的DNS服务</p>

<pre><code>8.8.8.8
8.8.4.4
</code></pre>

<p>3.下载John Malkowski的Debian OpenVPN脚本。</p>

<pre><code>wget http://vpsnoc.com/scripts/debian-openvpn.sh
chmod +x debian-openvpn.sh
./debian-openvpn.sh
</code></pre>

<p>连续填写server和client的信息，出现y/n的时候都选择y。 <br/>
然后把生成的<code>keys.tgz</code>下载自本地。</p>

<h2>不使用一键安装包，一步步自己安装</h2>

<p>以下内容参考了：<a href="http://www.vpser.net/build/linode-install-openvpn.html">VPS侦探 Linode VPS OpenVPN安装配置教程(基于Debian/Ubuntu)</a>    <br/>
1.安装</p>

<pre><code>apt-get install openvpn udev lzop
</code></pre>

<p>2.OpenVPN提供了”easy-rsa”这套加密方面的工具openvpn安装好之后easy-rsa在/usr/share/doc/openvpn/examples/easy-rsa/文件夹中为了使OpenVPN正常工作需要把easy-rsa复制到/etc/openvpn中.运行下列命令:</p>

<pre><code>#cp -R /usr/share/doc/openvpn/examples/easy-rsa/ /etc/openvpn
</code></pre>

<p>在<code>/etc/openvpn/easy-rsa/2.0/</code>中设置，基本所有的OpenVPN配置都在这。 <br/>
生产CA证书：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /etc/openvpn/easy-rsa/2.0
</span><span class='line'>source vars
</span><span class='line'>./clean-all
</span><span class='line'>./build-ca</span></code></pre></td></tr></table></div></figure>


<p><code>./build-ca</code>时会提示输入一些信息，可以都直接回车按默认信息。 <br/>
3.生成服务器端证书和密钥：</p>

<pre><code>./build-key-server server
</code></pre>

<p>有两次需要输入y。 <br/>
4.生产客户端证书和密钥：</p>

<pre><code>./build-key client
</code></pre>

<p>生成的证书和密钥在<code>/etc/openvpn/easy-rsa/2.0/keys/</code>下面。 <br/>
5.生成Diffie Hellman参数：</p>

<pre><code>./build-dh
</code></pre>

<p>6.安装配置openVPN客户端    详情见参考。</p>

<h2>windows客户端下载</h2>

<p>1.下载OpenVPN：<a href="http://www.openvpn.net/index.php/open-source/downloads.html">http://www.openvpn.net/index.php/open-source/downloads.html</a>下载最新版本安装包。 <br/>
2.安装，建议win7/vista用户安装到非系统分区。
3.修改虚拟网卡DNS，Google DNS :8.8.8.8和 8.8.4.4；OpenDNS的208.67.222.222 和208.67.220.220。 <br/>
4.将keys.tgz解压至openVPN安装目录下的config目录。 <br/>
5.运行openVPN。 <br/>
6.如果没有什么差错的话至此安装成功。 <br/>
可以进<a href="http://www.dnsstuff.com">http://www.dnsstuff.com</a> 或者facebook/twitter等测试下。惊喜等着你哦！ <br/>
如果需要和你的朋友分享这个，可以新建个用户，重新生成客户端证书。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /etc/openvpn/easy-rsa/2.0
</span><span class='line'> ./vars
</span><span class='line'>./build-key user1</span></code></pre></td></tr></table></div></figure>


<p>将新生成的user1.crt,user1.key,user1.csr三个文件和*.ovpn和ca.crt、ca.key三个文件一起下载到本地，编辑下载下来的<code>*.ovpn</code>文件将其中的<code>cert client1.crt</code>和<code>key client1.key</code>修改为：<code>cert user1.crt</code>和<code>key user1.key</code>。  <br/>
把以上文件，打包发送给你的朋友。并将其解压到config目录下。</p>

<br />


<p>本文地址：<a href="http://tinyxd.me/blog/2012/08/30/debian-ubuntu-setup-openvpn/">http://tinyxd.me/blog/2012/08/30/debian-ubuntu-setup-openvpn/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Dropbox备份VPS网站及数据库 ]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/27/use-dropbox-backup-vps-and-database/"/>
    <updated>2012-08-27T23:28:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/27/use-dropbox-backup-vps-and-database</id>
    <content type="html"><![CDATA[<p>用SSH客户端（PuTTY）登陆，进入root目录：</p>

<pre><code>cd ~
</code></pre>

<p>linux下用ssh登录：</p>

<pre><code>ssh (ip) -l (用户名) -p (端口号)
或者
ssh username@ip
或者  
ssh username@domain
</code></pre>

<p>下载dropbox程序： <br/>
32位版本：</p>

<pre><code>wget -O dropbox.tar.gz http://www.dropbox.com/download/?plat=lnx.x86
</code></pre>

<p>64位版本：</p>

<pre><code>wget -O - "https://www.dropbox.com/download?plat=lnx.x86_64
</code></pre>

<!--more-->


<p>解压缩：</p>

<pre><code>    tar -zxof dropbox.tar.gz
</code></pre>

<p>然后第一次运行dropbox：</p>

<pre><code>    ~/.dropbox-dist/dropboxd &amp;
</code></pre>

<p>运行后会出现一串URL地址，把这个复制到流量器上，跟你的dropbox账户进行绑定。
绑定好之后就可以开始同步了。 <br/>
首先进入dropbox，</p>

<pre><code>   cd ~/Dropbox
</code></pre>

<p>备份整个wwwroot目录，建立一个软连接：</p>

<pre><code>    ln -s /home/wwwroot
</code></pre>

<p>由于dropbox耗费的内存确实够大，建议不要开太长时间 <br/>
<img src="http://upload.tinyxd.me/2012/08/dropboxload.jpg"  alt="dropboxload" width="778" height="200"> <br/>
如果上面操作没有错误的话，在dropbox就可以看到同步的文件了。 <br/>
附别人写的一个脚本：</p>

<figure class='code'><figcaption><span>dropboxbak.sh </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="c">#!/bin/sh</span>
</span><span class='line'>    <span class="nv">BACKUP_SRC</span><span class="o">=</span><span class="s2">&quot;/root/Dropbox&quot;</span>  <span class="c">#用于同步的本地目录</span>
</span><span class='line'>    <span class="nv">BACKUP_WWW</span><span class="o">=</span><span class="s2">&quot;/home/wwwroot&quot;</span>     <span class="c">#你的网站目录</span>
</span><span class='line'>    <span class="nv">NOW</span><span class="o">=</span><span class="k">$(</span>date +<span class="s2">&quot;%Y.%m.%d&quot;</span><span class="k">)</span>
</span><span class='line'>    <span class="nv">MYSQL_SERVER</span><span class="o">=</span><span class="s2">&quot;127.0.0.1&quot;</span>
</span><span class='line'>    <span class="nv">MYSQL_USER</span><span class="o">=</span><span class="s2">&quot;user&quot;</span>
</span><span class='line'>    <span class="nv">MYSQL_PASS</span><span class="o">=</span><span class="s2">&quot;password&quot;</span>
</span><span class='line'>    <span class="nv">DAY</span><span class="o">=</span><span class="k">$(</span>date +<span class="s2">&quot;%u&quot;</span><span class="k">)</span>             <span class="c">#取当前星期，1表示周一</span>
</span><span class='line'>    start<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>   <span class="nb">echo </span>starting bak SQL
</span><span class='line'>    <span class="c">#dump数据库数据，以及备份网站整站文件</span>
</span><span class='line'>    mysqldump -u <span class="nv">$MYSQL_USER</span> -h <span class="nv">$MYSQL_SERVER</span> -p<span class="nv">$MYSQL_PASS</span> 需要备份的数据库名称 &gt; <span class="s2">&quot;$BACKUP_SRC/$NOW-Databases.sql&quot;</span>
</span><span class='line'>    <span class="nb">echo </span>starting dropbox
</span><span class='line'>    /root/.dropbox-dist/dropboxd &amp;
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    stop<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="nb">echo </span>stoping dropbox
</span><span class='line'>    pkill dropbox
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="s2">&quot;$1&quot;</span> in
</span><span class='line'>    start<span class="o">)</span>
</span><span class='line'>    start
</span><span class='line'>    ;;
</span><span class='line'>    stop<span class="o">)</span>
</span><span class='line'>    stop
</span><span class='line'>    ;;
</span><span class='line'>    <span class="k">esac</span>
</span></code></pre></td></tr></table></div></figure>


<p>将脚本放到~/.dropbox下，修改脚本权限：</p>

<pre><code>        chmod 755 ~/.dropbox/dropboxbak.sh
</code></pre>

<p>添加计划任务：</p>

<pre><code>        crontab –e
</code></pre>

<p>添加两条内容：</p>

<pre><code>            0   3 * * * sh /root/.dropbox/dropboxbak.sh start

            30 3 * * * sh /root/.dropbox/dropboxbak.sh stop
</code></pre>

<p>具体参数参照文档。 <br/>
删除dropbox的方法：</p>

<figure class='code'><figcaption><span>dropboxbak.sh </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># sh /root/.dropbox/dropboxbak.sh stop</span>
</span><span class='line'><span class="c"># su - root</span>
</span><span class='line'><span class="c"># cd</span>
</span><span class='line'><span class="c"># rm -rf .dropbox .dropbox-dist  Dropbox dropbox.tar.gz dbmakefakelib.py dbreadconfig.py</span>
</span></code></pre></td></tr></table></div></figure>


<br />


<p>本文地址：<a href="http://tinyxd.me/blog/2012/08/27/use-dropbox-backup-vps-and-database/">http://tinyxd.me/blog/2012/08/27/use-dropbox-backup-vps-and-database/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图床管理]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/26/imag-file-explorer/"/>
    <updated>2012-08-26T00:08:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/26/imag-file-explorer</id>
    <content type="html"><![CDATA[<p>做网站，尤其是做多个网站的，文件的统一管理，备份是很重要的。本站用<a href="http://encode-explorer.siineiolekala.net/">Encode Explorer</a>来管理本站图片、上传附件等。 <br/>
去Encode Explorer在sourceforge的<a href="http://sourceforge.net/projects/encode-explorer/files/encode-explorer/">项目官网</a>下载程序，其代码不过3k多行。只要将index.php上传到网站根目录，然后把nginx设置好用<a href="http://upload.tinyxd.me/">2级域名</a>指向此根目录，就可以了。    <br/>
其中index.php需要改几个地方：   <br/>
1.<code>$_CONFIG['lang'] = "zh_CN";</code> 支持中文  <br/>
2.<code>$_CONFIG['users'] = array(array('username', 'password', 'admin'));</code>  建立admin用户   <br/>
其中index.php介绍比较详细了。语法格式：array(username, password, status)    status为user可以查看目录但不可以修改，admin能够上传文件和删除文件。   <br/>
3.<code>$_CONFIG['new_dir_mode'] = 0755;</code>     <br/>
<code>$_CONFIG['upload_file_mode'] = 0644;</code> <br/>
修改新建文件夹和上传文件的默认权限。    <br/>
这就是最终完成的，用二级域名（只要将该域名dns解析到vps服务器地址就可以了）<a href="http://upload.tinyxd.me/">http://upload.tinyxd.me/</a>来上传/浏览/删除文件。  <br/>
本文参考了<a href="http://log4d.com/">log4d</a>的<a href="http://log4d.com/2012/05/image-host/">使用独立图床子域名</a>。</p>

<br />


<p>本文地址：<a href="http://tinyxd.me/blog/2012/08/26/imag-file-explorer/">http://tinyxd.me/blog/2012/08/26/imag-file-explorer/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vps lnmp配置优化]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/25/vps-optimization/"/>
    <updated>2012-08-25T23:40:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/25/vps-optimization</id>
    <content type="html"><![CDATA[<p>我选用了lnmp（linux + Nginx + PHP + MySQL ）来安装，方便快捷，安装后发现其实好多已经优化好了。  <br/>
其中需要注意到的有以下几个： <br/>
一. 基于xen架构的可以增加swap分区大小
我的vps是openVZ的，swap分区是不能随意更改的。PS.主机商已经提供了128M的swap了。满足了！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /var/
</span><span class='line'>dd if=/dev/zero of=swapfile bs=1024 count=262144
</span><span class='line'>/sbin/mkswap swapfile
</span><span class='line'>/sbin/swapon swapfile</span></code></pre></td></tr></table></div></figure>


<p>然后让自己做的swap分区在系统启动时自动加载：</p>

<pre><code>vi /etc/fstab   
</code></pre>

<p>在适当位置添加以下内容：</p>

<pre><code>/var/swapfile swap swap defaults 0 0
</code></pre>

<!--more-->


<p>二.Nginx主配置文件（nginx.conf）的优化
Nginx每个进程耗费10M~12M内存，只开启一个Nginx进程，节省内存。</p>

<pre><code>worker_processes 1;   
</code></pre>

<p>对网页文件、CSS、JS、XML等启动gzip压缩，减少数据传输量，提高访问速度。</p>

<pre><code>gzip on;
gzip_min_length  1k;
gzip_buffers     4 16k;
gzip_http_version 1.0;
gzip_comp_level 2;
gzip_types       text/plain application/x-javascript text/css application/xml;
gzip_vary on;
</code></pre>

<p>还有：</p>

<pre><code>location ~ .*\.(php|php5)?$
   {
     #将Nginx与FastCGI的通信方式由TCP改为Unix Socket。TCP在高并发访问下比Unix Socket稳定，但Unix Socket速度要比TCP快。
     fastcgi_pass  unix:/tmp/php-cgi.sock;
     #fastcgi_pass  127.0.0.1:9000;
     fastcgi_index index.php;
     include fcgi.conf;
   }

   location ~ /read.php
   {
     #将Nginx与FastCGI的通信方式由TCP改为Unix Socket。TCP在高并发访问下比Unix Socket稳定，但Unix Socket速度要比TCP快。
     fastcgi_pass  unix:/tmp/php-cgi.sock;
     #fastcgi_pass  127.0.0.1:9000;
     fastcgi_index index.php;
     include fcgi.conf;
   }

   #博客的图片较多，更改较少，将它们在浏览器本地缓存15天，可以提高下次打开我博客的页面加载速度。
   location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
   {
     expires      15d;
   } 

   #博客会加载很多JavaScript、CSS，将它们在浏览器本地缓存1天，访问者在看完一篇文章或一页后，再看另一篇文件或另一页的内容，无需从服务器再次下载相同的JavaScript、CSS，提高了页面显示速度。
   location ~ .*\.(js|css)?$
   {
     expires      1d;
   }   
</code></pre>

<p>其实上面说的lnmp自动安装包已经做好了这些优化！ <br/>
包括后面<a href="http://blog.s135.com/post/375/2/1/">这篇文章</a>提到的，lnmp已经配置好了。</p>

<br />


<p>对于新手的忠告，将配置改好后，记得reload，或者restart。 <br/>
经过优化后的vps，有人做过测试一小时，1000+的pv量都是没有问题的。相同的价格可见买vps还是比较合算的。 <br/>
PS.我的vps现在放了两个站：<a href="http://tinyxd.me/">本站</a>、<a href="http://info.tinyxd.me/">冰之竹语</a>。后期准备再弄个技术bbs之类的玩玩。 <br/>
对了我还放了个文件管理器<a href="http://encode-explorer.siineiolekala.net/">Encode Explorer</a>，专门用来存放上传的图片和文件的。地址在<a href="http://upload.tinyxd.me/">这里</a>。其实这一招是从<a href="http://log4d.com/2012/05/image-host/">这里</a>学来的。。。
我将在我的下一篇<a href="http://tinyxd.me/blog/2012/08/26/imag-file-explorer/">文章</a>中详细说明。</p>

<br />


<p>本文地址：<a href="http://tinyxd.me/blog/2012/08/25/vps-optimization/">http://tinyxd.me/blog/2012/08/25/vps-optimization/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux修改mac地址]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/23/archlinux-change-mac/"/>
    <updated>2012-08-23T00:03:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/23/archlinux-change-mac</id>
    <content type="html"><![CDATA[<p>快开学了，开学了紧接着就是找工作。由于今年的形势还不太好，所以最近一直在复习一些编程方面的东西，好久没更新文章了。 <br/>
还没到月底，自己的流量都已经用完了，悲催啊！！！借用别人的，这就需要修改mac地址。学校流量3G真的伤不起阿！！！囧 <br/>
查阅Archlinux Wiki可以看到有两种临时改变mac地址的方法：  <br/>
1.使用macchanger或者使用ip命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>macchanger --mac<span class="o">=</span>XX:XX:XX:XX:XX:XX
</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ip link <span class="nb">set </span>dev eth0 down
</span><span class='line'>ip link <span class="nb">set </span>dev eth0 address XX:XX:XX:XX:XX:XX
</span><span class='line'>ip link <span class="nb">set </span>dev eth0 up
</span></code></pre></td></tr></table></div></figure>


<p>2.在每次启动时自动修改MAC地址。   <br/>
创建文件<code>/etc/rc.d/functions.d/macspoof</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>spoof_mac<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  ip link <span class="nb">set </span>dev eth0 address XX:XX:XX:XX:XX:XX
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'>add_hook sysinit_end spoof_mac
</span></code></pre></td></tr></table></div></figure>


<p>具体可参见Archlinux wiki。</p>

<p>inode上网可参考我以前的一篇文章:<a href="http://tinyxd.me/blog/2012/05/25/archbang-arch-linux-an-zhuang-inode/">http://tinyxd.me/blog/2012/05/25/archbang-arch-linux-an-zhuang-inode/</a> <br/>
本文地址：<a href="http://tinyxd.me/blog/2012/08/23/archlinux-change-mac/">http://tinyxd.me/blog/2012/08/23/archlinux-change-mac/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VPS申请及博客搭建]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/14/vps-lnmp-setup-and-typecho-blog/"/>
    <updated>2012-08-14T00:33:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/14/vps-lnmp-setup-and-typecho-blog</id>
    <content type="html"><![CDATA[<p>前些天，在网上溜达时，突然看到一款免费的vps。不错。。。免费的。。。哥当时是激动啊，对于像我这样的屌丝，有免费的当然不会放过的。 <br/>
于是乎哥就开始折腾了。 <br/>
一、Vps申请 <br/>
Vps是host1free提供的（128MB,10G,无限流量），申请地址：<a href="http://www.host1free.com/free-vps/">http://www.host1free.com/free-vps/</a> ，看网上说，这已经是第三次开放注册了，一共2万个。最好翻墙注册，注册时最好用Gmail邮箱，不要用qq邮箱，然后就是耐心的等待了。建议大家，真心做正规站的来申请，做采集站的（包括采集类影视、小说、淘客及黑客、成人等违反TOS和中美法律内容）绕道吧。这个免费的vps对于想学习vps搭建博客的人实属不易。 <br/>
二、 安装lnmp</p>

<!--more-->


<p>参考<a href="http://lnmp.org/install.html">LNMP一键安装包</a>，其中会用到putty工具，可以到<a href="http://dl.pconline.com.cn/html_2/1/97/id=3978&amp;pn=0.html">这里</a>下载。 <br/>
按照上面的步骤进行操作。需要说明的是 <br/>
1. 第一条命令<code>screen –S lnmp</code>很重要，当网络突然掉线或者不小心putty被关掉时候，可以用<code>screen –r lnmp</code>看到之前lnmp所进行到的情况。对于没有screen的可以按照<a href="http://www.vpser.net/manage/run-screen-lnmp.html">这里</a>进行安装。 <br/>
2. 当需要将二级域名绑定到此空间时，我所用的博客工具是typecho，当添加了虚拟主机后，进入后台出现404错误，一般出现这样的情况是nginx设置伪静态的问题，这个情况lnmp已经帮我们解决了。但是，我的仍然出现了404问题，最后把<code>/usr/local/nginx/conf/nginx.conf</code>里面的server_name 和所绑定的域名重名了。只要随便改个名字就好了。  <br/>
三、 安装typecho  <br/>
安装过程，<a href="http://docs.typecho.org/install">官方文档</a>已经说的够详细了，这里就不再多说了。 <br/>
四、 数据库的备份问题  <br/>
数据备份，这个始终是个大问题。可以到<a href="http://www.vpser.net/vps-howto">这里</a>参考，也可以使用rsync来同步备份。 <br/>
五、关于新建站点  <br/>
至于这个新建的站点，其实想法还没有成熟，只是想分享一些互联网，linux方面的资讯，还有一些搞笑的轻松的话题。地址是：<a href="http://info.tinyxd.me">http://info.tinyxd.me</a>  <br/>
ps：博客还没有取名，希望大家给点建议。</p>

<br />


<p>关于vps，lnmp比较好的文章：  <br/>
<a href="http://www.cnblogs.com/amityat/archive/2011/08/23/2150177.html">LNMP一键安装升级nginx及php常用设置 SFTP管理指南</a> <br/>
<a href="http://www.vpser.net/vps-howto">VPS新手指南/教程</a></p>

<br />


<p>本站博客未特别注明，均为原创，转载请注明出处。 <br/>
本文地址：<a href="http://tinyxd.me/blog/2012/08/14/vps-lnmp-setup-and-typecho-blog/">http://tinyxd.me/blog/2012/08/14/vps-lnmp-setup-and-typecho-blog/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux堆的管理]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/09/linux-heap-management/"/>
    <updated>2012-08-09T18:32:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/09/linux-heap-management</id>
    <content type="html"><![CDATA[<p>每个Unix进程都拥有一个特殊的线性区，这个线性区就是所谓的堆（heap），堆用于满足进程的动态内存请求。内存描述符的start_brk与brk字段分别限定了这个区的开始地址和结束地址。</p>

<!--more-->


<p>进程可以使用下面的API来请求和释放动态内存：</p>

<p>malloc（size）</p>

<pre><code>请求size个字节的动态内存。如果分配成功，就返回所分配内存单元第一个字节的线性地址。 
</code></pre>

<p>calloc（n，size）</p>

<pre><code>请求含有n个大小为size的元素的一个数组。如果分配成功，就把数组元素初始化为0，并返回第一个元素的线性地址。 
</code></pre>

<p>realloc（ptr，size）</p>

<pre><code>改变由前面的malloc()或calloc()分配的内存区字段的大小。 
</code></pre>

<p>free（addr）</p>

<pre><code>释放由malloc()或calloc()分配的起始地址为addr的线性区。 
</code></pre>

<p>brk(addr)</p>

<pre><code>直接修改堆的大小。addr参数指定current-&gt;mm-&gt;brk的新值，返回值是线性区新的结束地址（进程必须检查这个地址和所请求的地址值addr是否一致）。  
</code></pre>

<p>sbrk(incr)</p>

<pre><code>类似于brk()，不过其中的incr参数指定是增加还是减少以字节为单位的堆大小。 
</code></pre>

<p>brk()函数和以上列出的函数有所不同，因为它是唯一以系统调用的方式实现的函数，而其他所有的函数都是使用brk()和mmap()系统调用实现的C语言库函数。</p>

<p>当用户态的进程调用brk()系统调用时，内核执行sys_brk(addr)函数。该函数首先验证addr参数是否位干进程代码所在的线性区。如 果 是，则立即返回，因为堆不能与进程代码所在的线性区重叠：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">end_code</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="nl">out:</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于brk()系统调用作用于某一个非代码的线性区，它分配和释放完整的页 。因此，该函数把addr的值调整为PAGE_SIZE的倍数，然后把调整的结果与内存描述符的brk字段的值进行比较：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">newbrk</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffff000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">oldbrk</span> <span class="o">=</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">+</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffff000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">oldbrk</span> <span class="o">==</span> <span class="n">newbrk</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果进程请求缩小堆，则sys_brk()调用do_munmap()函数完成这项任务，然后返回：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_munmap</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">newbrk</span><span class="p">,</span> <span class="n">oldbrk</span><span class="o">-</span><span class="n">newbrk</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果进程请求扩大堆，则sys_brk()首先检查是否允许进程这样做。如果进程企图分配在其跟制范围之外的内存，函数并不多分配内存，只简单地返回mm->brk的原有值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">rlim</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_DATA</span><span class="p">].</span><span class="n">rlim_cur</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">rlim</span> <span class="o">&lt;</span> <span class="n">RLIM_INFINITY</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_data</span> <span class="o">&gt;</span> <span class="n">rlim</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，函数检查扩大后的堆是否和进程的其他线性区相重叠，如果是，不做任何事情就返回：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">find_vma_intersection</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldbrk</span><span class="p">,</span> <span class="n">newbrk</span><span class="o">+</span><span class="n">PAGE_SIZE</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果一切都顺利，则调用do_brk()函数。如果它返回oldbrk,则分配成功且sys_brt()函数返回addr的值；否则，返回旧的mm->brk值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">do_brk</span><span class="p">(</span><span class="n">oldbrk</span><span class="p">,</span> <span class="n">newbrk</span><span class="o">-</span><span class="n">oldbrk</span><span class="p">)</span> <span class="o">==</span> <span class="n">oldbrk</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>do_brk()函数实际上是仅处理匿名线性区的do_mmap()的简化版。可以认为它的调用等价于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">do_mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">oldbrk</span><span class="p">,</span> <span class="n">newbrk</span><span class="o">-</span><span class="n">oldbrk</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_EXEC</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">MAP_FIXED</span><span class="o">|</span><span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，do_brk()比do_mmap()稍快，因为前者假定线性区不映射磁盘上的文件，从而避免了检查线性区对象的几个字段。</p>

<p>本文参考《深入理解linux内核》。 <br/>
本文地址：<a href="http://tinyxd.me/blog/2012/08/09/linux-heap-management/">http://tinyxd.me/blog/2012/08/09/linux-heap-management/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux系统调用]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/08/linux-system-calls/"/>
    <updated>2012-08-08T18:18:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/08/linux-system-calls</id>
    <content type="html"><![CDATA[<p><strong><em>摘要</em></strong>：操作系统为在用户态运行的进程与硬件设备（如CPU、磁盘、打印机等等）进行交互提供了一组接口。在应用程序和硬件之间设置一个额外层具有很多优点。首先，这使得编程更加容易，那用户从学习硬件设备的低级编程特性中解放出来。其次，这极大地提高了系统的安全性，因为内核在试图满足某个请求之前在接口级就可以检查这种请求的正确性。最后，更重要的是这些接口使得程序更具有可移植性，因为只要内核所提供的一组接口相同，那么在任一内核上就可以正确地编译和执行程序。</p>

<h2>简介     </h2>

<p>系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般都通过门(gate)陷入(trap)实现。系统调用是用户程序和内核交互的接口。 </p>

<!--more-->


<p>Linux系统在CPU的保护模式下提供了四个特权级别，目前内核都只用到了其中的两个特权级别，分别为“特权级0”和“特权级3”,[软间隔]级别0也就是我们通常所讲的内核模式，级别3也就是我们通常所讲的用户模式。划分这两个级别主要是对系统提供保护。内核模式可以执行一些特权指令和进入用[软间隔]户模式，而用户模式则不能。 </p>

<p>系统服务之所以需要通过系统调用提供给用户空间的根本原因是为了对系统“保护”，因为我们知道Linux的运行空间分为内核空间与用户空间，它们各自运行在不同的级别中，逻辑上相互隔离。所以用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用户用空间函数。比如我们熟悉的“hello world”程序（执行时）就是标准的户空间进程，它使用的打印函数printf就属于用户空间函数，打印的字符“hello word”字符串也属于用户空间数据。</p>

<p>但是很多情况下，用户进程需要获得系统服务（调用系统程序），这时就必须利用系统提供给用户的“特殊”接口——系统调用了，它的特殊性主要在于规定了用户进程进入内核的具体位置；换句话说用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的陷入内核的统一访问路径限制才能保证内核安全无虞。我们可以形象地描述这种机制：作为一个游客，你可以买票要求进入野生动物园，但你必须老老实实的坐在观光车上，按照规定的路线观光游览。当然，不准下车，因为那样太危险，不是让你丢掉小命，就是让你吓坏了野生动物。</p>

<h2>API和系统调用 </h2>

<p>应用编程接口（API）与系统调用有所不同，前者只是一个函数定义，说明了如何获得一个给定的服务；而后者是通过软中断向内核态发出一个明确的请求。</p>

<p>从编程者的观点看，API和系统调用之间的差别是没有关系的：唯一相关的事情就是函数名、参数类型及返回代码的含义。然而，从内核设计者的观点看，这种差别确实有关系，因为系统调用属于内核，而用户态的库函数不属于内核。</p>

<h2>系统调用、用户编程接口（API）、系统命令、和内核函数的关系 </h2>

<p>系统调用并非直接和程序员或系统管理员打交道，它仅仅是一个通过软中断机制（我们后面讲述）向内核提交请求，获取内核服务的接口。而在实际使用中程序员调用的多是用户编程接口——API，而管理员使用的则多是系统命令。</p>

<p>用户编程接口其实是一个函数定义，说明了如何获得一个给定的服务，比如read()、malloc()、free（）、abs()等。它有可能和系统调用形式上一致，比如read()接口就和read系统调用对应，但这种对应并非一一对应，往往会出现几种不同的API内部用到统一个系统调用，比如malloc()、free（）内部利用brk( )系统调用来扩大或缩小进程的堆；或一个API利用了好几个系统调用组合完成服务。更有些API甚至不需要任何系统调用——因为它不必需要内核服务，如计算整数绝对值的abs（）接口。</p>

<p>另外要补充的是Linux的用户编程接口遵循了在Unix世界中最流行的应用编程界面标准——POSIX标准，这套标准定义了一系列API。在Linux中（Unix也如此）这些API主要是通过C库（libc）实现的，它除了定义的一些标准的C函数外，一个很重要的任务就是提供了一套封装例程（wrapper routine）将系统调用在用户空间包装后供用户编程使用。</p>

<p>不过封装并非必须的，如果你愿意直接调用，Linux内核也提供了一个syscall()函数来实现调用，我们看个例子来对比一下通过C库调用和直接调用的区别。</p>

<p> </p>

<figure class='code'><figcaption><span>例子</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;syscall.h&gt; </span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt; </span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt; </span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt; </span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="kt">long</span> <span class="n">ID1</span><span class="p">,</span> <span class="n">ID2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*-----------------------------*/</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* 直接系统调用*/</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* SYS_getpid (func no. is 20) */</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*-----------------------------*/</span>
</span><span class='line'>
</span><span class='line'><span class="n">ID1</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_getpid</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;syscall(SYS_getpid)=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ID1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*-----------------------------*/</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* 使用&quot;libc&quot;封装的系统调用 */</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* SYS_getpid (Func No. is 20) */</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*-----------------------------*/</span>
</span><span class='line'>
</span><span class='line'><span class="n">ID2</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;getpid()=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ID2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p> </p>

<p>系统命令相对编程接口更高了一层，它是内部引用API的可执行程序，比如我们常用的系统命令ls、hostname等。Linux的系统命令格式遵循系统V的传统，多数放在/bin和/sbin下（相关内容可看看shell等章节）。</p>

<p>有兴趣的话可以通过strace ls或strace hostname 命令查看一下它们用到的系统调用，你会发现诸如open、brk、fstat、ioctl 等系统调用被用在系统命令中。</p>

<p>下一个需要解释一下的问题是内核函数和系统调用的关系，内核函数大家不要想像的过于复杂，其实它们和普通函数很像，只不过在内核实现，因此要满足一些内核编程的要求[3]。系统调用是一层用户进入内核的接口，它本身并非内核函数，进入内核后，不同的系统调用会找到对应到各自的内核函数——换个专业说法就叫：系统调用服务服务例程。实际对请求服务的是内核函数而非调用接口。</p>

<p>比如系统调用 getpid实际就是调用内核函数sys_getpid。</p>

<figure class='code'><figcaption><span>例子</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">sys_getpid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="err">       </span><span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tpid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Linux系统种存在许多的内核函数，有些是内核文件种自己使用的，有些则是可以export出来供内核其他部分共同使用的，具体情况自己决定。</p>

<p>内核公开的内核函数——export出来的——可以使用命令ksyms 或 cat /proc/ksyms来查看。另外网上还有一本归纳分类内核函数的书叫作《The Linux Kernel API Book》，有兴趣的读者可以去看看。</p>

<p>总而言之，从用户角度向内核看，依次是系统命令、编程接口、系统调用和内核函数。</p>

<h2>系统调用处理程序及服务例程 </h2>

<p>当用户态的进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数，在80x86体系结构中，可以用两种不同的方式调用Linux的系统调用。两种方式的最终结果都是跳转到所谓系统调用处理程序（systerm call handler）的汇编语言函数。</p>

<p>因为内核实现了很多不同的系统调用，因此进程必须传递一个名为系统调用号（systerm call number）的参数来识别所需的系统调用，eax寄存器就用作此目的。</p>

<p>所有的系统调用都返回一个整数值。这些返回值与封装例程返回值的约定是不同的。在内核中，正数或0表示系统调用成功结束，而负数表示一个出错条件。在后一种情况下，这个值就是存放在errno变量中必须返回给应用程序的负出错码。内核没有设置或使用errno变量，而封装例程从系统调用返回之后设置这个变量。</p>

<p>xyz()系统调用对应的服务例程的名字通常是sys_xyz()。不过也会有些例外。</p>

<p>Linux中实现系统调用利用了0x86体系结构中的软件中断[4]。软件中断和我们常说的中断(硬件中断)不同之处在于——它是通过软件指令触发而并非外设，也就是说又编程人员出发的一种异常，具体的讲就是调用int $0x80汇编指令，这条汇编指令将产生向量为128的编程异常。</p>

<p>之所以系统调用需要借助异常实现，是因为当用户态的进程调用一个系统调用时，CPU便被切换到内核态执行内核函数[5]，而我们在i386体系结构部分已经讲述过了进入内核——进入高特权级别——必须经过系统的门机制，这里异常实际上就是通过系统门陷入内核（除了int 0x80外用户空间还可以通过int3——向量3、into——向量4 、bound——向量5等异常指令进入内核，而其他异常用户空间程序无法利用，都是由系统使用的）。</p>

<p>我们更详细的解释一下这个过程。int $0x80指令目的是产生一个编号为128的编程异常，这个编程异常对应的中断描述符表IDT中的第128项——也就是对应的系统门描述符。门描述符中含有一个预设的内核空间地址，它指向了系统调用处理程序：system_call()（别和系统调用服务程序混淆,这个程序在entry.S文件中用汇编语言编写）。</p>

<p>很显然所有的系统调用都会统一的转到这个地址，但Linux一共有2、3百个系统调用都从这里进入内核后又该如何派发它们到各自的服务程序去呢？别发昏，解决这个问题的方法非常简单：首先Linux为每个系统调用都进行了编号（0—NR_syscall），同时在内核中保存了一张系统调用表，该表中保存了系统调用编号和其对应的服务例程，因此在系统调入通过系统门陷入内核前，需要把系统调用号一并传入内核，在x86上，这个传递动作是通过在执行int0x80前把调用号装入eax寄存器实现的。这样系统调用处理程序一旦运行，就可以从eax中得到数据，然后再去系统调用表中寻找相应服务例程了。</p>

<p>除了需要传递系统调用号以外，许多系统调用还需要传递一些参数到内核，比如sys_write(unsigned int fd, const char * buf, size_t count)调用就需要传递文件描述符号fd和要写入的内容buf和写入字节数count等几个内容到内核。碰到这种情况，Linux会有6个寄存器使用来传递这些参数：eax (存放系统调用号)、 ebx、ecx、edx、esi及edi来存放这些额外的参数（以字母递增的顺序）。具体做法是在system_call( )中使用SAVE_ALL宏把这些寄存器的值保存在内核态堆栈中。</p>

<p>有始便有终，当服务例程结束时，system_call( ) 从eax获得系统调用的返回值，并把这个返回值存放在曾保存用户态 eax寄存器栈单元的那个位置上。然后跳转到ret_from_sys_call( )，终止系统调用处理程序的执行。</p>

<p>当进程恢复它在用户态的执行前，RESTORE_ALL宏会恢复用户进入内核前被保留到堆栈中的寄存器值。其中eax返回时会带回系统调用的返回码。（负数说明调用错误，0或正数说明正常完成）</p>

<h2>参数传递 </h2>

<p>与普通函数类似，系统调用通常也需要输入/输出参数，这些参数可能是实际的值，也可能是用户态进程地址空间的变量，甚至是指向用户态函数的指针的数据结构地址。</p>

<p>普通C函数的参数传递是通过把参数值写入活动的程序栈（用户态栈或内核态栈）实现的。因为系统调用是一种横跨用户和内核两大陆地的特殊函数，所以既不能使用用户态栈也不能使用内核态栈。更确切地说，在发怵系统调用之前，系统调用的参数被写入CPU寄存器，然后在调用系统调用服务例程之前，内核再把存放在CPU中的参数拷贝到内核态堆栈中，这是因为系统调用服务例程是普通的C函数。</p>

<br >


<p>本文参考自《深入理解linux内核》和<a href="http://chriszeng87.iteye.com/blog/1204500">linux系统调用</a> 。 <br/>
本文地址：<a href="http://tinyxd.me/blog/2012/08/08/linux-system-calls/">http://tinyxd.me/blog/2012/08/08/linux-system-calls/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux缺页异常处理程序]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/07/linux-page-fault-exception/"/>
    <updated>2012-08-07T12:54:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/07/linux-page-fault-exception</id>
    <content type="html"><![CDATA[<p>Linux的缺页（Page Fault）异常处理程序必须区分以下两种情况：由编程错误所引起的异常，及由引用属于进程地址空间但还尚未分配物理页框的页所引起的异常。</p>

<p>线性区描述符可以让缺页异常处理程序非常有效地完成它的工作。do_page_fault()函数是80x86上的缺页中断服务程序，它把引起缺页的线性地址和当前进程的线性区相比较，从而能够根据和下图所示的方案选择适当的方法处理这个异常。</p>

<!--more-->


<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21159&authkey=ACvRvyPr-3BWicI" width="320" height="207" frameborder="0" scrolling="no"></iframe>


<p></p>

<p>在实际中，情况更复杂一些，因为缺页处理程序必须处理多种分得更细的特殊情况，它们不宜在总体方案中列出来，还必须区分许多种合理的访问。处理程序的详细流程图如图所示：</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21160&authkey=AFYUnmLPL0RCxXM" width="299" height="319" frameborder="0" scrolling="no"></iframe>


<p></p>

<p>本文参考自《深入理解linux内核》和<a href="http://blog.csdn.net/yunsongice/article/details/5637671">缺页异常处理程序</a> 。 <br/>
本文地址：<a href="http://tinyxd.me/blog/2012/08/07/linux-page-fault-exception/">http://tinyxd.me/blog/2012/08/07/linux-page-fault-exception/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux线性区]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/07/linux-linear-regions/"/>
    <updated>2012-08-07T12:43:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/07/linux-linear-regions</id>
    <content type="html"><![CDATA[<p><strong><em>摘要</em></strong>：内核使用一种新的资源成功实现了对进程动态内存的推迟分配。当用户态进程请求动态内存时，并没有获得请求的页框，而仅仅获得对一个新的线性地址区间的使用权，而这一线性地址区间就成为进程地址空间的一部分。这一区间叫做“线性区”（memory region）。</p>

<br />


<p>Linux通过类型为vm_area_struct的对象实现线性区。</p>

<p>每次运行一个程序，该程序的内容必须被放到进程的虚拟地址空间，对于可执行程序的共享库也是如此。可执行程序并非真正读到物理内存中，而只是链接到进程的虚拟内存中。</p>

<!--more-->


<p>不论我们运行某个程序多少次内存分配地址（bss、栈、堆、数据段、正文段）都是一样的。我们知道，linux操作系统每个进程的地址空间都是独立的，其实这里的独立说得是物理空间上得独立。即相同的虚拟地址，不同的物理地址。</p>

<p>当一个可执行程序映射到进程虚拟地址空间时，一组vm_area_struct数据结构将被产生。每个vm_area_struct数据结构表示可执行印象的一部分;是可执行代码，或是初始化的数据，以及未初始化的数据等。</p>

<p>　　linux操作系统是通过sys_exec对可执行文件进行映射以及读取的，有如下几步：</p>

<p>　　1.创建一组vm_area_struct</p>

<p>　　2.圈定一个虚拟用户空间，将其起始结束地址(elf段中已设置好)保存到vm_start和vm_end中。</p>

<p>　　3.将磁盘file句柄保存在vm_file中</p>

<p>　　4.将对应段在磁盘file中的偏移值(elf段中已设置好)保存在vm_pgoff中;</p>

<p>　　5.将操作该磁盘file的磁盘操作函数保存在vm_ops中</p>

<p>　　注意：这里没有对应 的页目录表项创建页表，更不存在设置页表项了。</p>

<p>每个线性区描述符表示一个线性地址区间。vm_start字段包含区间的第一个线性地址，而vm_end字段包含区间之外的第一个线性地址。vm_end - vm_start表示线性区的长度。vm_mm字段指向拥有这个区间的进程的mm_struct内存描述符。我们稍后将描述vm_area_struct的其他字段。</p>

<p>进程所拥有的线性区从来不重叠，并且内核尽力把新分配的线性区与紧邻的现有线性区进行合并。两个相邻区的访问权限如果相匹配，就能把它们合并在一起。</p>

<p>当一个新的线性地址区间加入到进程的地址空间时，内核检查一个已经存在的线性区是否可以扩大。如果不能，就创建一个新的线性区。类似地，如果从进程的地址空间删除一个线性地址区间，内核就要调整受影响的线性区大小。有些情况下，调整大小迫使一个线性区被分成两个更小的部分（从理论上说，如果没有空闲的内存给新的内存描述符使用，删除一个线性地址区间可能会失败，不过这种情况出现的概率太小太小）。</p>

<h2>线性区的数据结构 </h2>

<p>进程所拥有的所有线性区是通过一个简单的链表链接在一起的。出现在链表中的线性区是按内存地址的升序排列的；不过，每两个线性区可以由未用的内存地址区隔开。每个vm_area_struct元素的vm_next字段指向链表的下一个元素。内核通过进程的内存描述符的mmap字段来查找线性区，其中mmap字段指向链表中的第一个线性区描述符。</p>

<p>内存描述符的map_count字段存放进程所拥有的线性区数目。默认情况下，一个进程可以最多拥有65536个不同的线性区，系统管理员可以通过写/proc/sys/vm/max_map_count文件来修改这个限定值。</p>

<p>内核频繁执行的一个操作就是查找包含指定线性地址的线性区。由于链表是经过排序的，因此，只要在指定线性地址之后找到一个线性区，搜索就可以结束。</p>

<p>然而，仅当进程的线性区非常少时使用这种链表才是很方便的，比如说只有一二十个线性区。在链表中查找元素、插入元素、删除元素涉及许多操作，这些操作所花费的时间与链表的长度成线性比例。</p>

<p>尽管多数的Linux进程使用的线性区的数量非常少，但是诸如面向对象的数据库，或malloc()的专用调试器那样过于庞大的大型应用程序可能会有成百上千的线性区。在这种情况下，线性区链表的管理变得非常低效，因此，与内存相关的系统调用的性能就降低到令人无法忍受的程度。</p>

<p>Linux2.6实现了两种一种是线性的链表结构方便顺序索引，而红黑树的数据结构方便查找。</p>

<h2>红黑树    </h2>

<p>二叉排序树：每个元素（或说节点）通常有两个孩子：左孩子和右孩子。树中的元素被排序。对关键字为N的节点，它的左子树上的所有元素的关键字都比N小；相反，它的右子树上的所有元素的关键字都比N大。节点的关键字被写入节点内部。而除了具有基本的二叉排序树的特点以外，红-黑树必须满足下列5条规则：</p>

<p>1、每个节点必须或为黑或为红。</p>

<p>2、树的根必须为黑。</p>

<p>3、新插入的节点必须为红色。</p>

<p>4、红节点的孩子必须为黑。</p>

<p>5、从一个节点到后代叶子节点的每个路径都包含相同数量的黑节点。当统计黑节点个数时，空指针也算作黑节点。</p>

<p>这5条规则确保具有n个内部节点的任何红一黑树其高度最多为2 × log（n+l）。</p>

<p>在红-黑树中搜索一个元素因此而变得非常高效，因为其操作的执行时间与树大小的对数成线性比例。换句话说，双倍的线性区个数只多增加一次循环。</p>

<p>在红黑树中插入和删除一个元素也是高效的，因为算法能很快地遍历树以确定插入元素的位置或删除元素的位置。任何新节点必须作为一个叶子插入并着成红色。如果操作违背了上述规则，就必须移动或重新着色树的几个节点。</p>

<p>为了存放进程的线性区，Linux既使用了链表，也使用了红-黑树。这两种数据结构包含指向同一线性区描述符的指针，当插入或删除一个线性区描述符时，内核通过红-黑树搜索前后元素，并用搜索结果快速更新链表而不用扫描链表。</p>

<p>链表的头由内存描述符的mmap字段所指向。任何线性区对象都在vm_next字段存放指向链表下一个元素的指针。红-黑树的首部由内存描述符的mm_rb字段所指向。任和线性区对象都在类型为rb_node的vm_rb字段中存放节点颜色以及指向双亲、左孩子和右孩子的指针。</p>

<p>一般来说，红-黑树用来确定含有指定地址的线性区，而链表通常在扫描整个线性区集合时来使用。</p>

<h2>线性区访问权限 </h2>

<p>页与线性区的关系：我们使用“页”这个术语既表示一组线性地址和其物理地址对应的关系。尤其是，我们把介于0-4095之间的线性地址区间称为第0页，介于4096-8191之间的线性地址区间称为第1页，依此类推。因此每个线性区都由一组号码连续的页所构成。</p>

<p>与页相关的两种标志：</p>

<ul>
<li><p>在每个页表项中存放的几个标志，如：Read/Write、Present等（参见“常规分页”）。</p></li>
<li><p>存放在每个页描述符flags字段中的一组标志（参见的“页框管理”）。</p></li>
</ul>


<p>第一种标志由80x86硬件用来检查能否执行所请求的寻址类型；第二种标志由Linux用于许多不同的目的。</p>

<p>现在介绍第三种标志，即与线性区的页相关的那些标志。它们存放在vm_area_struct描述符的vm_flags字段中。一些标志给内核提供有关这个线性区全部页的信息，例如它们包含有什么内容，进程访问每个页的权限是什么。另外的标志描述线性区自身，例如它应该如何增长（这些标志位于include/linux/Mm.h）。</p>

<p>VM_READ：页是可读的</p>

<p>VM_WRITE：页是可写的</p>

<p>VM_EXEC：页是可执行的</p>

<p>VM_SHARED：页可以由几个进程共享</p>

<p>VM_MAYREAD：可以设置VM_READ标志</p>

<p>VM_MAYWRITE：可以设置VM_WRITE标志</p>

<p>VM_MAYEXEC：可以设置VM_EXEC标志</p>

<p>VM_MAYSHARE：可以设置VM_SHARE标志</p>

<p>VM_GROWSDOWN：线性区可以向低地址扩展</p>

<p>VM_GROWSUP：线性区可以向高地址扩展</p>

<p>VM_SHM：线性区用于IPC的共享内存</p>

<p>VM_DENYWRITE：线性区映射一个不能打开用于写的文件</p>

<p>VM_EXECUTABLE：线性区映射一个可执行文件</p>

<p>VM_LOCKED：线性区中的页被锁住，且不能换出</p>

<p>VM_IO：线性区映射设备的I/O地址空间</p>

<p>VM_SEQ_READ：应用程序顺序地访问页</p>

<p>VM_RAND_READ：应用程序以真正的随机顺序访问页</p>

<p>VM_DONTCOPY：当创建一个新进程时不拷贝线性区</p>

<p>VM_DONTEXPAND：通过mremap()系统调用禁止线性区扩展</p>

<p>VM_RESERVED：线性区是特殊的（如：它映射某个设备的I/O地址空间），因此它的页不能被交换出去</p>

<p>VM_ACCOUNT：创建IPC共享线性区时检查是否有足够的空闲内存用干映射</p>

<p>VM_HUGETLB：通过扩展分页机制处理线性区中的页</p>

<p>VM_NONLINEAR：线性区实现非线性文件映射</p>

<p>线性区描述符所包含的页访问权限可以任意组合。例如，存在这样一种可能性，允许一个线性区中的页可以执行但是不可以读取。为了有效地实现这种保护方案，与线性区的页相关的访问权限（读、写及执行）必须被复制到相应的所有表项中，以便由分页单元直接执行检查。换句话说，页访问权限表示何种类型的访问应该产生一个缺页异常。Linux委派缺页处理程序查找导致缺页的原因，因为缺页处理程序实现了许多页处理策略。</p>

<p>页表标志的初值（注意，同一线性区所有页标志的初值必须一样）存放在vm_area_struct描述符的vm_page_prot字段中。当增加一个页时，内核根据vm_page_prot字段的值设置相应页表项中的标志。</p>

<pre><code>typedef struct { unsigned long long pgprot; } pgprot_t;   /* include/asm-i386/Page.h */ 
</code></pre>

<p>然而，不能把线性区的访问权限直接转换成页保护位，这是因为：</p>

<ul>
<li><p>在某些情况下，即使由相应线性区描述符的vm flags字段所指定的某个页的访问权限允许对该页进行访问，但是，对该页的访问还是应当产生一个缺页异常。例如“写时复制”的情况，内核可能决定把属于两个不同进程的两个完全一样的可写私有页（它的VM_SHARE标志被清0）存入同一个页框中；在这种情况下，无论哪一个进程试图改动这个页都应当产生一个异常。</p></li>
<li><p>80x86处理器的页表仅有两个保护位，即Read/Write和User/Supervisor标志。此外，一个线性区所包含的任何一个页的User/Supervisor标志必须总置为1，因为用户态进程必须总能够访问其中的页。</p></li>
<li><p>启用PAE的新近Intel Pentium 4微处理器，在所有64位页表项中支持NX（No eXecute）标志。</p></li>
</ul>


<p>如果内核没有被编译成支持PAE，那么Linux采取以下规则以克服80x86微处理器的硬件限制：</p>

<ul>
<li><p>读访问权限总是隐含着执行访问权限，反之亦然。</p></li>
<li><p>写访问权限总是隐含着读访问权限。</p></li>
</ul>


<p>反之，如果内核被编译成支持PAE，而且CPU有NX标志，Linux就采取不同的规则：</p>

<ul>
<li><p>行访问权限总是隐含着读访问权限。</p></li>
<li><p>访问权限总是隐含着读访问权限。</p></li>
</ul>


<p>因此，要根据以下规则精简由读、写、执行和共享访问权限的16种可能组合：</p>

<ul>
<li><p>如果页具有写和共享两种访问权限，那么，Read/Write位被设置为1。</p></li>
<li><p>如果页具有读或执行访问权限，但是既没有写也没有共享访问权限，那么，Read/Write位被清0。</p></li>
<li><p>如果支持NX位，而且页没有执行访问权限，那么，把NX位设置为1。</p></li>
<li><p>如果页没有任何访问权限，那么，Presen七位被清0，以便每次访问都产生一个缺页异常。然而，为了把这种情况与真正的页框不存在的情况相区分，Linux还把Page size位置为1（你可能认为Page size位的这种用法并不正当，因为这个位本来是表示实际页的大小。但是，Linux可以侥幸逃脱这种骗局，因为80 x 86芯片在页目录项中检查Page size位，而不是在页表的表项中检查该位。）</p></li>
</ul>


<p>访问权限的每种组合所对应的精简后的保护位存放在protection_map数组的16个元素中（mm/Mmap.c）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pgprot_t protection_map[16] = { 
</span><span class='line'>
</span><span class='line'>__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111, 
</span><span class='line'>
</span><span class='line'>__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111 
</span><span class='line'>
</span><span class='line'>}; 
</span><span class='line'>
</span><span class='line'>//include/asm-i386/Pgtable.h 
</span><span class='line'>
</span><span class='line'>#define __P000 PAGE_NONE 
</span><span class='line'>
</span><span class='line'>#define __P001 PAGE_READONLY 
</span><span class='line'>
</span><span class='line'>#define __P010 PAGE_COPY 
</span><span class='line'>
</span><span class='line'>#define __P011 PAGE_COPY 
</span><span class='line'>
</span><span class='line'>#define __P100 PAGE_READONLY_EXEC 
</span><span class='line'>
</span><span class='line'>#define __P101 PAGE_READONLY_EXEC 
</span><span class='line'>
</span><span class='line'>#define __P110 PAGE_COPY_EXEC 
</span><span class='line'>
</span><span class='line'>#define __P111 PAGE_COPY_EXEC 
</span><span class='line'>
</span><span class='line'>#define __S000 PAGE_NONE 
</span><span class='line'>
</span><span class='line'>#define __S001 PAGE_READONLY 
</span><span class='line'>
</span><span class='line'>#define __S010 PAGE_SHARED 
</span><span class='line'>
</span><span class='line'>#define __S011 PAGE_SHARED 
</span><span class='line'>
</span><span class='line'>#define __S100 PAGE_READONLY_EXEC 
</span><span class='line'>
</span><span class='line'>#define __S101 PAGE_READONLY_EXEC 
</span><span class='line'>
</span><span class='line'>#define __S110 PAGE_SHARED_EXEC 
</span><span class='line'>
</span><span class='line'>#define __S111 PAGE_SHARED_EXEC </span></code></pre></td></tr></table></div></figure>


<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define COPY_EXEC / 
</span><span class='line'>
</span><span class='line'>__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)     </span></code></pre></td></tr></table></div></figure>


<br />


<p>本文章参考自《深入理解linux内核》 。 <br/>
本文地址：<a href="http://tinyxd.me/blog/2012/08/07/linux-linear-regions/">http://tinyxd.me/blog/2012/08/07/linux-linear-regions/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux进程地址空间]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/05/linux-process-address-space/"/>
    <updated>2012-08-05T12:51:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/05/linux-process-address-space</id>
    <content type="html"><![CDATA[<h2>简介   </h2>

<p>内核中获得动态内存的方式：<code>__get_free_pages()</code>或alloc_pages()从分区页框分配器中获得页框，kmem_cache_alloc()或kmalloc()使用slab分配器为专用或通用对象分配块，vmalloc()或vmalloc_32()获得一块非连续的内存区。如果所请求的内存区得以满足，这些函数都返回一个页描述符地址或线性地址（即所分配动态内存区的起始地址）。</p>

<p>使用以上简单方法的原因：</p>

<pre><code>内核是操作系统中优先级最高的成分 

内核信任自己。 
</code></pre>

<!--more-->


<p>当给用户态进程分配内存时：</p>

<pre><code>进程对动态内存的请求被认为是不紧迫的，内核总是尽量推迟给用户态进程分配动态内存。 

由于用户进程是不可信任的，因此 ，内核必须能随时准备捕获用户态进程引起的所有寻址错误。 
</code></pre>

<p>进程的地址空间（address space）由允许进程使用的全部线性地址组成。每个进程所看到的线性地址集合是不同的，一个进程所使用的地址与另外一个进程所使用的地址之间没有什么关系。后面我们会看到，内核可以通过增加或删除某些线性地址区间来动态修改进程的地址空间。</p>

<p>内核通过所谓线性区的资源来表示线性地址区间，线性区是由起始线性地址、长度和一些访问权限来描述的。为了效率起见，起始地址和线性区的长度都必须是4096的倍数，以便每个线性区所识别的数据完全填满分配给它的页框。</p>

<p>我们会在“缺页异常处理程序”博文中看到，确定一个进程当前所拥有的线性区（即进程的地址空间）是内核的基本任务，因为这可以让缺页异常处理程序有效地区分引发这个异常处理程序的两种不同类型的无效线性地址：</p>

<ul>
<li><p>由编程错误引发的无效线性地址。</p></li>
<li><p>由缺页引发的无效线性地址；即使这个线性地址属于进程的地址空间，但是对应于这个地址的页框仍然有待分配。</p></li>
</ul>


<p>从进程的观点来看，后一种地址不是无效的，内核要利用这种缺页以实现请求调页：内核通过提供页框来处理这种缺页，并让进程继续执行。</p>

<h2>内存描述符 </h2>

<p>与进程地址空间有关的全部信息都包含在一个叫做内存描述符（memory descriptor）的数据结构中，这个结构的类型为mm_struct，进程描述符的mm字段就指向这个结构。</p>

<p>所有的内存描述符存放在一个双向链表中。每个描述符在mmlist段存放链表相邻元素的地址。链表的第一个元素是init_mm的mmlist字段，init_mm是初始化阶段进程0所使用的内存描述符。mmlist_lock自旋锁保护多处理器系统对链表的同时访问（同样是位于include/linux/Sched.h）：</p>

<p>extern spinlock_t mmlist_lock;</p>

<p>mm_users字段存放共享mm_struct数据结构的轻进程的个数。mm_count字段是内存描述符的主是使用计数器，在mm_users次使用计数器中的所有用户在mm_count中只作为一个单位。每当mm_count递减时，内核都要检查它是否变为0，如果是，就要解除这个内存描述符，因为不再有用户使用它。</p>

<p>我们用一个例子来解释mm_users和mm_count之间的不同。如果一个内存描述符由两个轻量级进程共享。它的mm_users字段通常存放的值为2，而mm_count字段存放的值为1（两个所有者进程算作一个）。</p>

<p>如果把内存描述符暂时借给一个内核线程，那么，内核就增加mm_count。这样，即使两个轻量级进程都死亡，且mm_users字段变为0，这个内存描述符也不被释放，直到内核线程使用完为止，因为mm_count字段仍然大于0。</p>

<p>但是，如果内核想确保内存描述符在一个长操作的中间不被释放，那么，就应该增加mm_users字段而不是mm_coont字段的值。最终的结果是相同的，因为mm_users的增加确保了mm_count不变为0，即使拥有这个内存描述符的所有轻进程全部死亡。</p>

<h2>内核线程的内存描述符 </h2>

<p>内核线程仅运行在内核态，因此，它们永远不会访问低于TASK_SIZE（等于PAGE_OFFSET，通常为0xc0000000，即768MB)的地址。与普通进程相反，内核线程不用线性区（vm_area_struct），因此，内存描述符的很多字段对内核线程是没有意义的。</p>

<p>因为大于TASK_SIZE线性地址的相应页表项都应该总是相同的，因此，一个内核线程到底使用什么样的页表集根本就没有什么关系。为了避免无用的TLB和高速缓存刷新，内核线程使用一组最近运行的普通进程的页表。所以，我们在每个进程描述符中包含了两种内存描述符的指针：mm和active_mm。</p>

<p>进程描述符中的mm字段指向进程所拥有的内存描述符，而active_mm字段指向进程运行时所使用的内存描述符。对于普通进程而言，这两个字段存放相同的指针。但是，内核线程不拥有任何内存描述符，因此，它们的mm字段总是为NULL。当内核线程得以运行时，他的active_mm字段被初始化为前一个运行进程的active_mm值。</p>

<br />


<p>本文章参考自《深入理解linux内核》 。 <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/08/05/linux-process-address-space/">http://tinyxd.me/blog/2012/08/05/linux-process-address-space/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写在开博两个月]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/02/blog-two-months/"/>
    <updated>2012-08-02T18:46:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/02/blog-two-months</id>
    <content type="html"><![CDATA[<p>其实今天距离开博两个月还有几天的时间，因为今天PR变为2，所以写篇短文，记录下。  <br/>
ps：今天和麦子做的网站&#8212;-<a href="http://www.aitinan.com/">挨踢男的那点事（专注移动互联网）</a>加了友链。其中不乏原创文章，写的很好。推荐大家去逛逛。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[awk 学习]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/08/01/awk-study/"/>
    <updated>2012-08-01T00:15:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/08/01/awk-study</id>
    <content type="html"><![CDATA[<p>AWK是一种优良的文本处理工具。它不仅是 Linux 中也是任何环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母）的最大功能取决于一个人所拥有的知识。AWK 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。</p>

<h2>一、awk调用方式 </h2>

<p>1、awk [-F field-separator] &#8216;commands&#8217; input-file(s)</p>

<p>commands 是真正的awk命令</p>

<p>-F 为域分隔符</p>

<!--more-->


<p>2、第二种方法是将所有a w k命令插入一个文件，并使a w k程序可执行，然后用a w k命令解释</p>

<p>器作为脚本的首行，以便通过键入脚本名称来调用它。</p>

<p>3、第三种方式是将所有的a w k命令插入一个单独文件，然后调用：</p>

<p>awk -f awk-script-file input-files(s)</p>

<p><code>-f</code>选项指明在文件awkscriptfile中的awk脚本， inputfile(s)是使用awk进行浏览的文件</p>

<p>名。</p>

<h2>二、awk脚本 </h2>

<p>1、awk由模式和动作组成，模式部分决定动作语句何时触发及触发事件</p>

<p>模式可以是任何条件语句或复合语句或正则表达式。 模式包括两个特殊字段BEGIN和END</p>

<p>如：</p>

<p>awk &#8216;BEGIN{print &#8220;Name\n&#8212;&#8211;&#8221;}{print $1}END{&#8220;end-of-report&#8221;}&#8217;</p>

<p>2、域和记录</p>

<p>awk执行时，其浏览域标记为$1、$2&#8230;$n</p>

<p>$0指所有域</p>

<p>保存awk输出</p>

<p>(1)、awk &#8216;{print $0}&#8217; grade.txt >wow 即内容重定向</p>

<p>(2)、使用tee命令 awk &#8216;{print $0}&#8217; grade.txt | tee wow 既显示有写入文件</p>

<p>3、元字符</p>

<p>\ ^ $ . [] | () * + ?</p>

<p>其中：</p>

<p><code>+</code>使用+匹配一个或多个字符</p>

<p>？ 匹配模式出现频率。例如使用/XY?Z/匹配XYZ或YZ</p>

<p>4、条件操作符</p>

<p>&lt; 小于</p>

<p><code>&gt;= 大于等于</code></p>

<p>&lt;= 小于等于</p>

<p>~ 匹配正则表达式</p>

<p>== 等于</p>

<p>!~ 不匹配正则表达式</p>

<p>!= 不等于</p>

<p>(1)、awk &#8216;{if($4~/Brown/) print $0}&#8217; grade.txt</p>

<p>其中if后面的条件用()括起来</p>

<p>(2)、设置大小写 awk &#8216;/[Gg]reen/&#8217; grade.txt</p>

<p>(3)、任意字符<code>awk '$1~/^...a/' grade.txt</code></p>

<p>(4)、或关系匹配 awk &#8216;$0~/(Yellow)|(Brown)/&#8217; grade.txt</p>

<p>各表达式互相结合起来的表达式：</p>

<p>&amp;&amp; AND : 语句两边必须同时匹配为真。</p>

<p>|| OR：语句两边同时或其中一边匹配为真。</p>

<p>! 非求逆</p>

<p>5、内置变量</p>

<p>ARGC 命令行参数个数</p>

<p>ARGV 命令行参数排列</p>

<p>ENVIRON 支持队列中系统环境变量的使用</p>

<p>FILENAME awk浏览的文件名</p>

<p>FNR 浏览文件的记录数</p>

<p>FS 设置输入域分隔符，等价于命令行- F选项</p>

<p>NF 浏览记录的域个数</p>

<p>NR 已读的记录数</p>

<p>OFS 输出域分隔符</p>

<p>ORS 输出记录分隔符</p>

<p>RS 控制记录分隔符</p>

<h2>三、awk操作符 </h2>

<p>= += *= / = %= ^ = 赋值操作符</p>

<p>？   条件表达操作符</p>

<p>|| &amp;&amp; !   或、与、非（上一节已讲到）</p>

<p>~!~   匹配操作符，包括匹配和不匹配</p>

<p>&lt; &lt;= == != >>  关系操作符</p>

<p><code>+ - * / % ^  算术操作符</code></p>

<p><code>+ + --   前缀和后缀</code></p>

<p>1、设置输入域到域变量名</p>

<p>cat crontab.bak  | awk &#8216;BEGIN{numall=20}{if($1~/[0-9]*/ &amp;&amp; $i>numall &amp;&amp; NR &lt; 10) num+=$1} END{print num}&#8217;</p>

<h2>四、内置的字符串函数 </h2>

<p>gsub(r,s) 在整个$ 0中用s替代r</p>

<p>gsub(r,s,t) 在整个t中用s替代r</p>

<p>index(s,t) 返回s中字符串t的第一位置</p>

<p>length(s) 返回s长度</p>

<p>match(s,r) 测试s是否包含匹配r的字符串</p>

<p>split( s,a,fs) 在fs上将s分成序列a</p>

<p>sprint(fmt,exp) 返回经fmt格式化后的exp</p>

<p>sub(r,s) 用$ 0中最左边最长的子串代替s</p>

<p>substr(s,p) 返回字符串s中从p开始的后缀部分</p>

<p>substr(s,p,n) 返回字符串s中从p开始长度为n的后缀部分</p>

<p>实例：</p>

<p>1、awk &#8217; BEGIN{numall=10}{gsub(12,20);if($1~/[0-9]*/  &amp;&amp; NR &lt; 10) num+=length($0);print substr($0,1,index($0,&#8221;=&#8221;));} END{print num}&#8217;</p>

<p>2、awk &#8216;BEGIN {print split(&#8220;123#456#678&#8221;,myarray,&#8221;#&#8221;)}&#8217;</p>

<p>   awk &#8216;BEGIN { split(&#8220;123#456#678&#8221;,myarray,&#8221;#&#8221;);print myarray[2]}&#8217;</p>

<h2>五、字符串屏蔽序列 </h2>

<p>\b 退格键 \t tab键</p>

<p>\f 走纸换页 \ddd 八进制值</p>

<p>\n 新行 \c 任意其他特殊字符，例如\为反斜线符号</p>

<p>\r 回车键</p>

<p>1、printf修饰符</p>

<p><code>- 左对齐</code></p>

<p>Width 域的步长，用0表示0步长</p>

<p>.prec 最大字符串长度，或小数点右边的位数</p>

<p>%c ASCII字符</p>

<p>%d 整数</p>

<p>%e 浮点数，科学记数法</p>

<p>%f 浮点数，例如（123.44）</p>

<p>%g awk决定使用哪种浮点数转换e或者f</p>

<p>%o 八进制数</p>

<p>%s 字符串</p>

<p>%x 十六进制数</p>

<p>如：awk &#8216;{printf &#8220;%-15s %s&#8221;,$1,$3}&#8217;</p>

<br /> 


<p>本文<strong>转载</strong>自<a href="http://www.xuephp.com/main/detail.php?cid=22838">awk学习整理和使用实例</a>。  <br/>
本文地址：<a href="http://tinyxd.me/blog/2012/08/01/awk-study/">http://tinyxd.me/blog/2012/08/01/awk-study/</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内存管理（下）]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/07/31/linux-memory-management-3/"/>
    <updated>2012-07-31T23:51:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/07/31/linux-memory-management-3</id>
    <content type="html"><![CDATA[<p><strong><em>摘要</em></strong>：把一块存放slab结构的内存区映射到一组连续的页框是最好的选择，这样会充分利用高速缓存并获得较低的平均访问时间。不过，上面的方式主要是针对那些使用非常频繁的内核数据结构——如task_struct、inode来设计的。如果对内存区的请求不是很频繁，那么，通过连续的线性地址，而不是物理地址来访问非连续的物理页框这样一种分配模式就会很有意义了。这种模式的主要优点是避免了外碎片，而缺点是必须打乱内核页表。此外，非连续内存区的大小必须是4096 的倍数。Linux 在几个方面使用非连续内存区：为活动的交换区分配数据结构，为模块分配空间，或者给某些I/O 驱动程序分配缓冲区等。此外，非连续内存区还提供了另一种使用高端内存页框的方法。</p>

<h2>非连续内存区的线性地址    </h2>

<p>要查找线性地址的一个空闲区，我们可以从PAGE_OFFSET开始查找（通常为0xc0000000，即第4 个GB 的起始地址）。下图让我们回忆了如何使用第4个GB 的线性地址：</p>

<!--more-->


<p>回忆一下：</p>

<iframe src="https://skydrive.live.com/embed?cid=1F260DE1061FCF3E&resid=1F260DE1061FCF3E%21156&authkey=ABbb5MTrh96mmAU" width="317" height="94" frameborder="0" scrolling="no"></iframe>


<p>（1）内存区的开始部分包含的是对前896MB RAM 进行映射的线性地址。直接映射的物理内存末尾所对应的线性地址保存在high_memory全局变量中。当物理内存小于896MB，则线性地址0xc0000000以后的896MB与其一一对应；当物理内存大于896MB而小于4GB时，只直接映射前896MB的地址到0xc0000000以后的线性空间，然后把线性空间的其他部分与896MB和4GB物理空间映射起来，称为动态重映射，这是本博的重点；当物理内存大于4GB，则需要考虑PAE的情况，其他的东东没什么区别，我们不做过多的回忆了。</p>

<p>（2）内核的页表由内核页全局目录变量swapper_pg_dir维护；pagetable_init()建立内核页表项。</p>

<p>（3）内存区的结尾部分包含的是固定映射的线性地址，主要用于存放一些常量线性地址，具体查看“高端内存映射”博文。</p>

<p>（4）从PKMAP_BASE 开始，我们查找用于高端内存页框的永久内核映射的线性地址，具体查看“高端内存映射 ”博文。</p>

<p>（5）其余的线性地址可以用于非连续内存区。在物理内存映射的末尾与第一个内存区之间插入一个大小为8MB（宏VMALLOC_OFFSET）的安全区，目的是为了“捕获”对内存的越界访问。出于同样的理由，插入其他4KB 大小的安全区来隔离非连续的内存区。</p>

<h2>非连续内存区的描述符 </h2>

<p>每个非连续内存区都对应着一个类型为vm_struct 的描述符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct vm_struct { 
</span><span class='line'>
</span><span class='line'>    void            *addr; 
</span><span class='line'>
</span><span class='line'>    unsigned long        size; 
</span><span class='line'>
</span><span class='line'>    unsigned long        flags; 
</span><span class='line'>
</span><span class='line'>    struct page        **pages; 
</span><span class='line'>
</span><span class='line'>    unsigned int        nr_pages; 
</span><span class='line'>
</span><span class='line'>    unsigned long        phys_addr; 
</span><span class='line'>
</span><span class='line'>    struct vm_struct    *next; 
</span><span class='line'>
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>介绍下它的字段：</p>

<p>void *    addr    内存区内第一个内存单元的线性地址（首址）</p>

<p>unsigned long    size    内存区的大小加4096（内存区之间的安全区间的大小）</p>

<p>unsigned long    flags    非连续内存区映射的内存的类型</p>

<p>struct page **    pages    指向nr_pages数组的指针，该数组由指向页描述符的指针组成</p>

<p>unsigned int    nr_pages    内存区填充的页的个数</p>

<p>unsigned long    phys_addr    该字段设为0，除非内存已被创建来映射一个硬件设备的I/O 共享内存</p>

<p>struct vm_struct *    next    指向下一个vm_struct结构的指针</p>

<h2>分配非连续内存区 </h2>

<p>vmalloc()函数给内核分配一个非连续内存区。参数size表示所请求内存区的大小。如果这个函数能够满足请求，就返回新内存区的起始地址；否则，返回一个NULL 指针（mm/ vmalloc.c）</p>

<p>其工作方式类似于kmalloc()，只不过vmalloc()分配的内存虚拟地址是连续的，而物理地址则无需连续。这也是用户空间分配函数的工作方式：由malloc()返回的页在进程的虚拟地址空间内是连续的，但是，这并不保证它们在物理RAM中也连续。kmalloc()函数确保页在物理地址上是连续的（虚拟地址自然也是连续的）。vmalloc()函数只确保页在虚拟地址空间内是连续的。vmalloc()仅在不得已时才会使用——一般是在为了获得大块内存时，例如，当模块被动态插入到内核中时，就把模块装载到由vmalloc()分配的内存上。</p>

<p>伙伴关系也好、slab技术也好，从内存管理理论角度而言目的基本是一致的，它们都是为了防止“分片”，不过分片又分为外部分片和内部分片之说，所谓内部分片是说系统为了满足一小段内存区（连续）的需要，不得不分配了一大区域连续内存给它，从而造成了空间浪费；外部分片是指系统虽有足够的内存，但却是分散的碎片，无法满足对大块“连续内存”的需求。无论何种分片都是系统有效利用内存的障碍。slab分配器使得一个页面内包含的众多小块内存可独立被分配使用，避免了内部分片，节约了空闲内存。伙伴关系把内存块按大小分组管理，一定程度上减轻了外部分片的危害，因为页框分配不在盲目，而是按照大小依次有序进行，不过伙伴关系只是减轻了外部分片，但并未彻底消除。你自己比划一下多次分配页面后，空闲内存的剩余情况吧。</p>

<p>所以避免外部分片的最终思路还是落到了如何利用不连续的内存块组合成“看起来很大的内存块”——这里的情况很类似于用户空间分配虚拟内存，内存逻辑上连续，其实映射到并不一定连续的物理内存上。Linux内核借用了这个技术，允许内核程序在内核地址空间中分配虚拟地址，同样也利用页表（内核页表）将虚拟地址映射到分散的内存页上。以此完美地解决了内核内存使用中的外部分片问题。内核提供vmalloc函数分配内核虚拟内存，该函数不同于kmalloc，它可以分配较Kmalloc大得多的内存空间（可远大于128K，但必须是页大小的倍数），但相比Kmalloc来说,Vmalloc需要对内核虚拟地址进行重映射，必须更新内核页表，因此分配效率上要低一些（用空间换时间）。</p>

<h2>释放函数   </h2>

<p>vfree()函数释放vmalloc()或vmalloc_32()创建的非连续内存区，而vunmap()函数释放vmap()创建的内存区。两个函数都使用同一个参数 —— 将要释放的内存区的起始线性地址address；它们都依赖于<code>__vunmap()</code>函数来做实质性的工作。</p>

<p><code>__vunmap()</code>函数接收两个参数：将要释放的内存区的起始地址的地址addr，以及标志deallocate_pages，如果被映射到内存区内的页框应当被释放到分区页框分配器（调用vfree()）中，那么这个标志被置位，否则被清除（vunmap()被调用）。该函数执行以下操作：</p>

<ol>
<li><p>调用remove_vm_area()函数得到vm_struct 描述符的地址area，并清除非连续内存区中的线性地址对应的内核的页表项。</p></li>
<li><p>如果deallocate_pages 被置位，函数扫描指向页描述符的area->pages指针数组；对于数组的每一个元素，调用<code>__free_page()</code>函数释放页框到分区页框分配器。此外，执行kfree(area->pages)来释放数组本身。</p></li>
<li><p>调用kfree(area)来释放vm_struct 描述符。</p></li>
</ol>


<br />


<p>本文章参考自《linux内核设计与实现》、<a href="http://blog.csdn.net/jiangyuping_fyl/article/details/7268287">slab分配器</a> 及 <a href="http://blog.csdn.net/yunsongice/article/details/5536197">非连续内存区</a> 。 <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/31/linux-memory-management-3/">http://tinyxd.me/blog/2012/07/31/linux-memory-management-3/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内存管理（中）]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/07/31/linux-memory-management-2/"/>
    <updated>2012-07-31T23:16:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/07/31/linux-memory-management-2</id>
    <content type="html"><![CDATA[<p><strong><em>摘要</em></strong>：slab分配器是Linux内存管理中非常重要和复杂的一部分，其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统。slab分配对象时，会使用最近释放的对象内存块，因此其驻留在CPU高速缓存的概率较高。</p>

<h2>简介</h2>

<!--more-->


<p>内存管理的目标是提供一种方法，为实现各种目的而在各个用户之间实现内存共享。内存管理方法应该实现以下两个功能：</p>

<ul>
<li><p>最小化管理内存所需的时间</p></li>
<li><p>最大化用于一般应用的可用内存（最小化管理开销）</p></li>
</ul>


<p>内存管理实际上是一种关于权衡的零和游戏。您可以开发一种使用少量内存进行管理的算法，但是要花费更多时间来管理可用内存。也可以开发一个算法来有效地管理内存，但却要使用更多的内存。最终，特定应用程序的需求将促使对这种权衡作出选择。</p>

<p>每个内存管理器都使用了一种基于堆的分配策略。在这种方法中，大块内存（称为 堆）用来为用户定义的目的提供内存。当用户需要一块内存时，就请求给自己分配一定大小的内存。堆管理器会查看可用内存的情况（使用特定算法）并返回一块内存。搜索过程中使用的一些算法有 first-fit（在堆中搜索到的第一个满足请求的内存块 ）和 best-fit（使用堆中满足请求的最合适的内存块）。当用户使用完内存后，就将内存返回给堆。</p>

<p>这种基于堆的分配策略的根本问题是碎片（fragmentation）。当内存块被分配后，它们会以不同的顺序在不同的时间返回。这样会在堆中留下一些洞，需要花一些时间才能有效地管理空闲内存。这种算法通常具有较高的内存使用效率（分配需要的内存），但是却需要花费更多时间来对堆进行管理。</p>

<p>另外一种方法称为 buddy memory allocation，是一种更快的内存分配技术，它将内存划分为 2 的幂次方个分区，并使用 best-fit 方法来分配内存请求。当用户释放内存时，就会检查 buddy 块，查看其相邻的内存块是否也已经被释放。如果是的话，将合并内存块以最小化内存碎片。这个算法的时间效率更高，但是由于使用 best-fit 方法的缘故，会产生内存浪费。</p>

<p>伙伴系统算法采用页框作为基本内存区，适合对大块内存的请求，为了解决外碎片的问题。而小内存的分配，会产生内碎片（internal fragmentation），这需要新的数据结构来描述在同一页框中 如何分配小内存区。</p>

<p>为了满足内核对这种小内存块的需要，Linux系统采用了一种被称为slab分配器的技术。Slab分配器的实现相当复杂，但原理不难，其核心思想就是“存储池[2]”的运用。内存片段（小块内存）被看作对象，当被使用完后，并不直接释放而是被缓存到“存储池”里，留做下次使用，这无疑避免了频繁创建与销毁对象所带来的额外负载。</p>

<p>Slab技术不但避免了内存内部分片（下文将解释）带来的不便（引入Slab分配器的主要目的是为了减少对伙伴系统分配算法的调用次数——频繁分配和回收必然会导致内存碎片——难以找到大块连续的可用内存），而且可以很好利用硬件缓存提高访问速度。</p>

<p>Slab并非是脱离伙伴关系而独立存在的一种内存分配方式，slab仍然是建立在页面基础之上，换句话说，Slab将页面（来自于伙伴关系管理的空闲页框链）撕碎成众多小内存块以供分配，slab中的对象分配和销毁使用kmem_cache_alloc与kmem_cache_free。每个高速缓存都是由kmem_cache_t(等价于struct kmem_cache)</p>

<p>slab分配器把对象分组放进高速缓存。包含高速缓存的主内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框既包含已分配的对象，也包含空闲的对象。内核周期性地扫描高速缓存并释放空slab对应的页框。</p>

<p>普通高速缓存在系统初始化期间调用kmem_cache_init()和kmem_cache_sizes_init()来建立普通高速缓存。专用高速缓存由kmem_cache_create()函数创建。所有普通和专用高速缓存的名字都可以在运行期间通过读取/proc/slabinfo文件得到。这个文件也指明每个高速缓存中空闲对象的个数和已分配对象的个数。</p>

<p>slab的对象描述符与slab描述符本身类似，也可以用两种可能的方式来存放：外部对象描述符（存放在slab的外部）、内部对象描述符（存放在slab的内部）。每个对象都有类型为kmem_bufctl_t的一个描述符。</p>

<h2>API 函数 </h2>

<p>现在来看一下能够创建新 slab 缓存、向缓存中增加内存、销毁缓存的应用程序接口（API）以及 slab 中对对象进行分配和释放操作的函数。</p>

<p>第一个步骤是创建 slab 缓存结构，您可以将其静态创建为：</p>

<p>struct struct kmem_cache *my_cachep;</p>

<p>然后其他 slab 缓存函数将使用该引用进行创建、删除、分配等操作。kmem_cache 结构包含了每个中央处理器单元（CPU）的数据、一组可调整的（可以通过 proc 文件系统访问）参数、统计信息和管理 slab 缓存所必须的元素。</p>

<p>kmem_cache_create</p>

<p>内核函数 kmem_cache_create 用来创建一个新缓存。这通常是在内核初始化时执行的，或者在首次加载内核模块时执行。其原型定义如下：</p>

<p>struct kmem_cache * kmem_cache_create( const char <em>name, size_t size, size_t align,                        unsigned long flags;                        void (</em>ctor)(void<em>, struct kmem_cache </em>, unsigned long),                        void (<em>dtor)(void</em>, struct kmem_cache *, unsigned long));</p>

<p>name 参数定义了缓存名称，proc 文件系统（在 /proc/slabinfo 中）使用它标识这个缓存。 size 参数指定了为这个缓存创建的对象的大小， align 参数定义了每个对象必需的对齐。 flags 参数指定了为缓存启用的选项。这些标志如表 1 所示。</p>

<p>表 1. kmem_cache_create 的部分选项（在 flags 参数中指定）</p>

<p>选项                  说明</p>

<p>SLAB_RED_ZONE      在对象头、尾插入标志，用来支持对缓冲区溢出的检查。</p>

<p>SLAB_POISON            使用一种己知模式填充 slab，允许对缓存中的对象进行监视（对象属对象所有，不过可以在外部进行修改）。</p>

<p>SLAB_HWCACHE_ALIGN             指定缓存对象必须与硬件缓存行对齐。</p>

<p>ctor 和 dtor 参数定义了一个可选的对象构造器和析构器。构造器和析构器是用户提供的回调函数。当从缓存中分配新对象时，可以通过构造器进行初始化。</p>

<p>在创建缓存之后， kmem_cache_create 函数会返回对它的引用。注意这个函数并没有向缓存分配任何内存。相反，在试图从缓存（最初为空）分配对象时，refill 操作将内存分配给它。当所有对象都被使用掉时，也可以通过相同的操作向缓存添加内存。</p>

<p>kmem_cache_destroy</p>

<p>内核函数 kmem_cache_destroy 用来销毁缓存。这个调用是由内核模块在被卸载时执行的。在调用这个函数时，缓存必须为空。</p>

<p>void kmem_cache_destroy( struct kmem_cache *cachep );</p>

<p>kmem_cache_alloc</p>

<p>要从一个命名的缓存中分配一个对象，可以使用 kmem_cache_alloc 函数。调用者提供了从中分配对象的缓存以及一组标志：</p>

<p>void kmem_cache_alloc( struct kmem_cache *cachep, gfp_t flags );</p>

<p>这个函数从缓存中返回一个对象。注意如果缓存目前为空，那么这个函数就会调用 cache_alloc_refill 向缓存中增加内存。kmem_cache_alloc 的 flags 选项与 kmalloc 的 flags 选项相同。表 2 给出了标志选项的部分列表。</p>

<p>表 2. kmem_cache_alloc 和 kmalloc 内核函数的标志选项</p>

<p>标志    说明</p>

<p>GFP_USER 为用户分配内存（这个调用可能会睡眠）。</p>

<p>GFP_KERNEL       从内核 RAM 中分配内存（这个调用可能会睡眠）。</p>

<p>GFP_ATOMIC         使该调用强制处于非睡眠状态（对中断处理程序非常有用）。</p>

<p>GFP_HIGHUSER       从高端内存中分配内存。</p>

<p>kmem_cache_zalloc</p>

<p>内核函数 kmem_cache_zalloc 与 kmem_cache_alloc 类似，只不过它对对象执行 memset 操作，用来在将对象返回调用者之前对其进行清除操作。</p>

<p>kmem_cache_free</p>

<p>要将一个对象释放回 slab，可以使用 kmem_cache_free。调用者提供了缓存引用和要释放的对象。</p>

<p>void kmem_cache_free( struct kmem_cache <em>cachep, void </em>objp );</p>

<p>kmalloc 和 kfree</p>

<p>内核中最常用的内存管理函数是 kmalloc 和 kfree 函数。这两个函数的原型如下：</p>

<p>void <em>kmalloc( size_t size, int flags ); void kfree( const void </em>objp );</p>

<p>注意在 kmalloc 中，惟一两个参数是要分配的对象的大小和一组标志（请参看 表 2 中的部分列表）。但是 kmalloc 和 kfree 使用了类似于前面定义的函数的 slab 缓存。kmalloc 没有为要从中分配对象的某个 slab 缓存命名，而是循环遍历可用缓存来查找可以满足大小限制的缓存。找到之后，就（使用 <code>__kmem_cache_alloc</code>）分配一个对象。要使用 kfree 释放对象，从中分配对象的缓存可以通过调用 virt_to_cache 确定。这个函数会返回一个缓存引用，然后在 __cache_free 调用中使用该引用释放对象。</p>

<h2>其他函数 </h2>

<p>slab 缓存 API 还提供了其他一些非常有用的函数。 kmem_cache_size 函数会返回这个缓存所管理的对象的大小。您也可以通过调用kmem_cache_name 来检索给定缓存的名称（在创建缓存时定义）。缓存可以通过释放其中的空闲 slab 进行收缩。这可以通过调用kmem_cache_shrink 实现。注意这个操作（称为回收）是由内核定期自动执行的（通过 kswapd）。</p>

<p>unsigned int kmem_cache_size( struct kmem_cache <em>cachep ); const char </em>kmem_cache_name( struct kmem_cache <em>cachep ); int kmem_cache_shrink( struct kmem_cache </em>cachep );</p>

<h2>补充： </h2>

<p>如果对存储区的请求不频繁，就用一组普通高速缓存来处理，普通高速缓存中的对象具有几何分布的大小，范围为32~131072字节。</p>

<p>使用kmalloc()函数申请，kfree()释放。</p>

<br />


<p>本文章参考自《深入理解linux内核》及 <a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/">动态内存管理</a>。 <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/31/linux-memory-management-2/">http://tinyxd.me/blog/2012/07/31/linux-memory-management-2/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内存管理（上）]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/07/29/linux-memory-management-1/"/>
    <updated>2012-07-29T23:33:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/07/29/linux-memory-management-1</id>
    <content type="html"><![CDATA[<p><strong><em>摘要</em></strong>：内核如何给自己分配动态内存呢？</p>

<p>“页框管理”和“内存区管理”是对连续物理内存区处理的两种不同技术。</p>

<p>“非连续内存区管理”是处理非连续内存区的第三种技术。</p>

<h2>页框管理  </h2>

<p>intel的Pentium处理器可以采用两种不同的页框大小：4KB和4MB。Linux采用4KB页框大小作为标准的内存分配单元。物理页在系统中由页框结构struct paga描述，系统中所有的页框存储在数组mem_map[]中，可以通过该数组找到系统中的每一页（空闲或非空闲）。</p>

<!--more-->


<h2>内存管理区  </h2>

<p>Linux2.6把每个内存节点的物理内存划分为3个管理区（zone）。在80X86UMA体系结构中的管理区为：</p>

<p>ZONE_DMA：包含低于16MB的内存页框</p>

<p>ZONE_NORMAL：包含高于16MB且低于896MB的内存页框</p>

<p>ZONE_HIGHMEM：包含从896MB开始高于896MB的内存页框（并不映射在内核线性地址空间的第4个GB）</p>

<p>注意：ZONE_DMA和ZONE_NORMAL区包含内存的“常规”页框，通过把它们线性映射到线性地址空间的第4个GB，内核就可以直接进行访问。相反，ZONE_HIGHMEM区包含的内存页不能由内核直接访问，尽管它们也线性地映射到了线性地址空间的第4个GB。在64位体系结构上ZONE_HIGHMEM区总是空的。</p>

<p>Linux内核管理物理内存是通过分页机制实现的，它将整个内存划分成无数4k(在i386体系结构中)大小页，从而分配和回收内存的基本单位便是内存页了。利用分页管理有助于灵活分配内存地址，因为分配时不必要求必须有大块的连续内存，系统可以东一页、西一页的凑出所需要的内存供进程使用。虽然如此，但是实际上系统使用内存还是倾向于分配连续的内存块，因为分配连续内存时，页表不需要更改，因此能降低TLB的刷新率（频繁刷新会很大增加访问速度）。</p>

<p>鉴于上述需求，内核分配物理页为了尽量减少不连续情况，采用了“伙伴”关系来管理空闲页框。伙伴关系分配算法大家不应陌生——几乎所有操作系统书都会提到,我们不去详细说它了，如果不明白可以参看有关资料。这里只需要大家明白Linux中空闲页面的组织和管理利用了伙伴关系，因此空闲页面分配时也需要遵循伙伴关系，最小单位只能是2的幂倍页面大小。内核中分配空闲页框的基本函数是get_free_page/get_free_pages，它们或是分配单页或是分配指定的页框（2、4、8…512页）。</p>

<p>注意：get_free_page是在内核中分配内存，不同于malloc在用户空间中分配，malloc利用堆动态分配，实际上是调用brk()系统调用，该调用的作用是扩大或缩小进程堆空间（它会修改进程的brk域）。如果现有的内存区域不够容纳堆空间，则会以页面大小的倍数位单位，扩张或收缩对应的内存区域，但brk值并非以页面大小为倍数修改，而是按实际请求修改。因此Malloc在用户空间分配内存可以以字节为单位分配,但内核在内部仍然会是以页为单位分配的。</p>

<h2>高端内存页框的内核映射  </h2>

<p>内核可以采用三种不同的机制将页框映射到高端内存；分别叫做永久内核映射、临时内核映射及非连续内存分配。</p>

<p>永久内核映射可能阻塞当前进程，不能用于中断处理程序和可延迟函数。</p>

<p>临时内核映射比永久内核映射的实现要简单，可以用在中断处理程序和可延迟函数的内部，因为它们从不阻塞当前进程。</p>

<h2>伙伴系统算法（buddy systerm）  </h2>

<p>内核要分配一组连续的页框，必须建立一种健壮、高效的分配策略。为此，必须解决著名的外部碎片（external fragmentation）问题。频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。</p>

<p>Linux 采用伙伴系统（buddy system）算法来解决外碎片问题。把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1, 2, 4, 8, 16, 32, 64, 128, 256，512和1024 个连续的页框。对1024 个页框的最大请求对应着4MB 大小的连续RAM块。每个块的第一个页框的物理地址是该块大小的整数倍。例如，大小为16 个页框的块，其起始地址是16 × 212（212 ＝ 4096，这是一个常规页的大小）的倍数。</p>

<p>本文章参考自《深入理解linux内核》及 <a href="http://www.cnblogs.com/hoys/archive/2011/09/08/2171606.html">Linux内存管理(上)</a> 。 <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/29/linux-memory-management-1/">http://tinyxd.me/blog/2012/07/29/linux-memory-management-1/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux进程调度]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/07/26/linux-process-scheduling/"/>
    <updated>2012-07-26T23:18:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/07/26/linux-process-scheduling</id>
    <content type="html"><![CDATA[<p><strong><em>摘要</em></strong>：linux与任何分时系统一样，通过一个进程到另一个进程的快速切换，达到表面上看来的多个进程同时执行的神奇效果。</p>

<br />


<p>Linux的调度基于分时（time sharing）技术：多个进程以“时间多路复用”方式运行，因为CPU的时间被分成“片（slice）”，给每个可运行进程分配一片。</p>

<p>在linux中，进程的优先级是动态的。调度程序跟踪进程正在做什么，并周期性地调整它们的优先级。</p>

<h2>分类 </h2>

<p>传统上，把进程分类为“IO受限（IO bound）”或“CPU受限（CPU bound）”。前者频繁使用IO设备，并花费很多时间等待IO操作的完成；而后者则需要大量CPU时间的数值计算应用程序。</p>

<p>另一种分类方法把进程区分为三类：交互式进程（interactive process）、批处理进程（batch process、实时进程（real-time process）。</p>

<!--more-->


<p></p>

<h2>进程的抢占 </h2>

<p>Linux的进程是抢占式的。根据优先级和时间片是否国企决定是否可以被抢占。</p>

<p>Linux2.6内核是抢占式的，这意味着进程无论是处于内核态还是用户态，都可能被抢占。</p>

<h2>调度算法 </h2>

<p>调度程序总能成功地找到要执行的进程。事实上，总是至少有一个可运行进程，即swapper进程，它的PID等于0，而且它只有在CPU不能执行其他进程时才执行。</p>

<p>每个Linux进程总是按照下面的调度类型被调度：</p>

<p>SCHED_FIFO（先进先出的实时进程）：直到先被执行的进程变为非可执行状态，后来的进程才被调度执行。在这种策略下，先来的进程可以执行sched_yield系统调用，自愿放弃CPU，以让权给后来的进程；</p>

<p>SCHED_RR（时间片轮转的实时进程）：轮转调度。内核为实时进程分配时间片，在时间片用完时，让下一个进程使用CPU；</p>

<p>SCHED_NORMAL（普通的分时进程）。</p>

<h2>普通进程的调度 (参考自<a href="http://hi.baidu.com/_kouu/blog/item/52471ab5e90e7c788ad4b24a.html">linux进程调度浅析</a>) </h2>

<p>实时进程调度的中心思想是，让处于可执行状态的最高优先级的实时进程尽可能地占有CPU，因为它有实时需求；而普通进程则被认为是没有实时需求的进程，于是调度程序力图让各个处于可执行状态的普通进程和平共处地分享CPU，从而让用户觉得这些进程是同时运行的。</p>

<p>每个普通进程都有它自己的静态优先级，还有动态优先级。</p>

<p>与实时进程相比，普通进程的调度要复杂得多。内核需要考虑两件麻烦事：</p>

<p>一、动态调整进程的优先级</p>

<p>按进程的行为特征，可以将进程分为“交互式进程”和“批处理进程”：</p>

<p>交互式进程（如桌面程序、服务器、等）主要的任务是与外界交互。这样的进程应该具有较高的优先级，它们总是睡眠等待外界的输入。而在输入到来，内核将其唤醒时，它们又应该很快被调度执行，以做出响应。比如一个桌面程序，如果鼠标点击后半秒种还没反应，用户就会感觉系统“卡”了；</p>

<p>批处理进程（如编译程序）主要的任务是做持续的运算，因而它们会持续处于可执行状态。这样的进程一般不需要高优先级，比如编译程序多运行了几秒种，用户多半不会太在意；</p>

<p>如果用户能够明确知道进程应该有怎样的优先级，可以通过nice、setpriority系统调用来对优先级进行设置。（如果要提高进程的优先级，要求用户进程具有CAP_SYS_NICE能力。）</p>

<p>然而应用程序未必就像桌面程序、编译程序这样典型。程序的行为可能五花八门，可能一会儿像交互式进程，一会儿又像批处理进程。以致于用户难以给它设置一个合适的优先级。</p>

<p>再者，即使用户明确知道一个进程是交互式还是批处理，也多半碍于权限或因为偷懒而不去设置进程的优先级。（你又是否为某个程序设置过优先级呢？）</p>

<p>于是，最终，区分交互式进程和批处理进程的重任就落到了内核的调度程序上。</p>

<p>调度程序关注进程近一段时间内的表现（主要是检查其睡眠时间和运行时间），根据一些经验性的公式，判断它现在是交互式的还是批处理的？程度如何？最后决定给它的优先级做一定的调整。</p>

<p>进程的优先级被动态调整后，就出现了两个优先级：</p>

<p>1、用户程序设置的优先级（如果未设置，则使用默认值），称为静态优先级。这是进程优先级的基准，在进程执行的过程中往往是不改变的；</p>

<p>2、优先级动态调整后，实际生效的优先级。这个值是可能时时刻刻都在变化的；</p>

<p>二、调度的公平性</p>

<p>在支持多进程的系统中，理想情况下，各个进程应该是根据其优先级公平地占有CPU。而不会出现“谁运气好谁占得多”这样的不可控的情况。</p>

<p>linux实现公平调度基本上是两种思路：</p>

<p>1、给处于可执行状态的进程分配时间片（按照优先级），用完时间片的进程被放到“过期队列”中。等可执行状态的进程都过期了，再重新分配时间片；</p>

<p>2、动态调整进程的优先级。随着进程在CPU上运行，其优先级被不断调低，以便其他优先级较低的进程得到运行机会；</p>

<p>后一种方式有更小的调度粒度，并且将“公平性”与“动态调整优先级”两件事情合而为一，大大简化了内核调度程序的代码。因此，这种方式也成为内核调度程序的新宠。</p>

<p>强调一下，以上两点都是仅针对普通进程的。而对于实时进程，内核既不能自作多情地去动态调整优先级，也没有什么公平性可言。</p>

<p>普通进程具体的调度算法非常复杂，并且随linux内核版本的演变也在不断更替（不仅仅是简单的调整），所以本文就不继续深入了。有兴趣的朋友可以参考下面的链接：</p>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/">《Linux 调度器发展简述》</a></p>

<p><a href="http://blog.chinaunix.net/u1/42957/showart.php?id=337597">《鼠眼看Linux调度器》</a></p>

<p><a href="http://blog.chinaunix.net/u1/42957/showart.php?id=337604">《鼠眼再看Linux调度器［1］》</a></p>

<p><a href="http://blog.chinaunix.net/u1/42957/showart.php?id=337607">《鼠眼再看Linux调度器［2］》</a></p>

<h2>实时进程的调度 </h2>

<p>每个实时进程都与一个实时优先级相关，实时优先级是一个范围从1（最高优先级）~99（最低优先级）的值。调度程序总是让优先级高的进程运行，换句话说，实时进程运行的过程中，禁止低优先级的进程的执行。与普通进程相反，实时进程总是被当成活动进程。用户可以通过系统调用sched_setparam()和sched_setscheduler()改变进程的实时优先级。</p>

<p>只有在下述时间之一发生时，实时进程才会被另一个进程取代：</p>

<pre><code>进程被另外一个具有更高实时优先级的实时进程抢占 

进程执行了阻塞操作并进入睡眠（处于TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE状态）。 

进程停止（处于TASK_STOPPED或TASK_TRACED状态）或被杀死（处于EXIT_ZOMBIE或EXIT_DEAD状态）。 

进程通过调用系统调用sched_yield()自愿放弃CPU。 

进程是基于时间片轮转的实时进程（SCHED_RR），而且用完了它的时间片。 
</code></pre>

<p>数据结构runqueue是Linux2.6调度程序最重要的数据结构。系统中的每个CPU都有它自己的运行队列，所有的runqueue结构存放在runqueues每CPU变量中。</p>

<h2>调度程序所使用的函数 </h2>

<p>scheduler_tick()：维持当前最新的time_slice计数器</p>

<p>try_to_wake_up()：唤醒睡眠进程</p>

<p>recalc_task_prio()：更新进程的动态优先级</p>

<p>schedule()：选择要被执行的新进程</p>

<p>load_balance()：维持多处理器系统中运行队列的平衡</p>

<h2>多处理器系统中运行队列的平衡 </h2>

<p>Linux一直坚持采用对称多处理模式，这意味着，与其他CPU相比，内核不对一个CPU有任何偏向，但是，多处理器机器具有很多不同的风格，而且调度程序的实现随硬件特征的不同而有所不同，我们将特别关注下面三种不同类型的多处理器机器：</p>

<p>（1）标准的多处理器体系结构</p>

<p>直到最近，这是多处理器机器最普通的体系结构。这些机器所共有的RAM芯片集被所有CPU共享。</p>

<p>（2）超线程</p>

<p>超线程芯片是一个立刻执行几个执行线程的微处理器；它包括几个内部寄存器的拷贝，并快速在它们之间切换。这种由Intel发明的技术，使得当前线程在访问内存的间隙，处理器可以使用它的机器周期去执行另外一个线程。一个超线程的物理CPU可以被Linux看作几个不同的逻辑CPU。</p>

<p>（3）NUMA</p>

<p>把CPU和RAM以本地“结点”为单位分组，（通常一个结点包括一个CPU和几个RAM芯片）。内存仲裁器（一个使系统中的CPU以串型方式访问RAM的专用电路）是典型的多处理器系统的瓶颈。在NUMA体系结构中，当CPU访问与它同在一个结点中的“本地”RAM芯片时，几乎没有竞争，因此访问通常是非常快的。另一方面，访问它所属结点外的“远程”RAM芯片就非常慢。</p>

<h2>与调度相关的系统调用 </h2>

<p>nice()、getpriority()和setpriority()系统调用、sched_getaffinity()和sched_setaffinity()调用</p>

<h2>与实时进程相关的系统调用 </h2>

<p>sched_getscheduler()和sched_setscheduler()系统调用、sched_getparam()和sched_setparam()系统调用、sched_yield()系统调用、sched_get_priority_min()和 sched_get_priority_max()系统调用、sched_rr_get_interval()系统调用</p>

<br />


<p>本文章参考自《深入理解linux内核》。 <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/26/linux-process-scheduling/">http://tinyxd.me/blog/2012/07/26/linux-process-scheduling/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux系统定时测量]]></title>
    <link href="http://lkunxyz.github.com/blog/2012/07/26/linux-timing-measurements/"/>
    <updated>2012-07-26T12:48:00+08:00</updated>
    <id>http://lkunxyz.github.com/blog/2012/07/26/linux-timing-measurements</id>
    <content type="html"><![CDATA[<p>Linux内核必须完成的两种主要定时测量：</p>

<p>保存当前的时间和日期，以便通过time()、ftime()、gettimeofday()系统调用把它们返回给用户程序，也可以由内核本身把当前时间作为文件和网络包的时间戳。</p>

<p>维持定时器，这种机制能够告诉内核或用户程序某一时间间隔已经过去了。</p>

<p>一般会遇到的几种时钟和定时器电路：实时时钟（Real Time Clock RTC）、时间戳计数器（Time Stamp Counter TSC）、可编程间隔定时器（Programmable Interval Timer PIT）、CPU本地定时器（APIC中）、高精度事件定时器（HPET）、ACPI电源管理定时器。</p>

<p>Linux的计时体系结构是一组与时间流相关的内核数据结构和函数。实际上，基于80x86多处理器机器所具有的计时体系结构与单处理器机器所具有的稍有不同：</p>

<p>在三处理器系统上，所有的计时活动都是由全局定时器（可以是可编程间隔定时器也可以是高精度事件定时器）产生的中断触发的。</p>

<!--more-->


<p>在多处理器系统上，所有普通的活动（像软定时器处理）都是由全局定时器产生的中断触发的，而具体的CPU的活动（像监控当前运行进程的执行时间）是由本地APIC定时器产生的中断触发的。</p>

<p>jiffies</p>

<p>jiffies是一个计数器，用来记录自系统启动依赖产生的节拍总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值。因为一秒内时钟中断的次数等于Hz，所以jiffies一秒内增加的值也就为Hz。系统运行时间以秒为单位计算，就等于jiffies/Hz。</p>

<p>xtime</p>

<p>xtime变量存放当前时间和日期；它是一个timespec类型的数据结构，该结构有两个字段：</p>

<p>1.tv_sec 存放自1970年1月1日（UTC）午夜以来经过的秒数。</p>

<p>2.tv_nsec存放自上一秒开始经过的纳秒数（它的值域范围在0-999999999之间）</p>

<p>在单处理器系统上，所有与定时有关的活动都是由IRQ线0上的可编程间隔定时器产生的中断触发的。</p>

<p>多处理器系统可以依赖两种不同的时钟中断源：可编程间隔定时器或高精度事件定时器产生的中断，以及CPU本地定时器产生的中断(监管内核代码并检测当前进程在特定CPU上已经运行了多长时间)。</p>

<p>内核在于定时相关的其他任务中必须周期性地收集若干数据用于：</p>

<pre><code>检查运行进程的CPU资源限制  

更新与本地CPU工作负载有关的统计数  

计算平均系统负载  

监管内核代码  
</code></pre>

<p>软定时器和延迟函数</p>

<p>定时器是一种软件功能，即允许在将来的某个时期，函数在给定的时间间隔用完时被调用。超时（time-out）表示与定时器相关的时间间隔已经用完的那个时刻。</p>

<p>Linux考虑两种类型的定时器，即动态定时器（dynamic timer）和间隔定时器（interval timer）。第一种类型由内核使用，而间隔定时器可以由进程在用户态创建。</p>

<p>延迟函数</p>

<p>当内核需要等待一个较短的时间间隔（比方说，不超过几毫秒）时，就不需要使用软定时器。</p>

<p>开发驱动，需要较短的时间间隔，在以上情况下，内核使用udelay()和ndelay()函数：前者接收一个微妙级的时间间隔作为它的参数，并在指定的延迟结束后返回；后者与前者类似，但是指定的延迟参数是纳秒级的。</p>

<p>本文章参考自《深入理解linux内核》。 <br/>
本站文章如果没有特别说明，均为<strong>原创</strong>，转载请以<strong>链接</strong>方式注明本文地址：<a href="http://tinyxd.me/blog/2012/07/26/linux-timing-measurements/">http://tinyxd.me/blog/2012/07/26/linux-timing-measurements/</a></p>
]]></content>
  </entry>
  
</feed>
